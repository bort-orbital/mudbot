The following is a manual for TinyMUSH, but it mostly applies also to TinyMUX which is based off
the PennMUSH codebase

MUSH Manual Version 2.008
  Written for TinyMUSH version 2.2.1
              TinyMUSH version 2.0.10 patchlevel 5
              PennMUSH version 1.50 patchlevel 12
              MudCore Starter Database version 1.0
  Copyright 1993, 1994, 1995, Lydia Leong (lwl@netcom.com / Amberyl)

Section I: Getting Started. Basic commands and objects.

Introduction: A brief history of MUSH. Configurations and server differences.

1. The Basics
 1.1  Some information
        Common terms used on MUSHes.
        The format of this manual.
 1.2  Basic commands
         Looking around: look, examine, @decompile, TERSE, MYOPIC, @grep
         Communications: ", :, @emits, page, whisper, basic flags and @set,
            HAVEN, GAGGED, NOSPOOF
         Going places: JUMP_OK, @tel, @whereis, UNFINDABLE
         Objects: get, drop, give, ENTER_OK, inventory
         Command syntax, @set and flags, special commands, @list
 1.3  Attributes: @desc, @succ, @fail, @drop, @kill, IMMORTAL, @move, @sex
 1.4  Editing: @edit, @mvattr, @cpattr
 1.5  Do it!  --  basic character set-up
 1.6  A parser discussion
2. Objects
 2.1  Basic object commands: @create, @destroy, @force, @name, VISUAL
 2.2  Puppets - the PUPPET flag. ROBOTs.
 2.3  A Note about Privacy: @sweep
 2.4  Attributes on Objects: Action Lists
 2.5  Machines: @cost, @pay, and @clone, QUIET and DESTROY_OK flags, @parent
 2.6  Limiting object uses: @charges and @runout
 2.7  Reacting to the environment: @listen and @ahear, ^, LISTENER/MONITOR
 2.8  Keeping your objects safe: @lock, @unlock, @chown, CHOWN_OK, STICKY,
         @search, @find, @stats
 2.9  Do it!  --  falcon

Section II: Building and an introduction to programming

3. Building.
 3.1  Creating a room: @dig, FLOATING flag
 3.2  Connecting rooms: @open, @link and @unlink, LINK_OK flag, @entrances
 3.3  Refinements: ABODE and JUMP_OK flags, drop-tos and STICKY flag on rooms
 3.4  Exit conventions and the TRANSPARENT flag
 3.5  Do it!   --  home
4. Introduction to Programming
 4.1  The stack and string substitutions - % substitutions
 4.2  General attributes and action lists - @trigger and GET()
 4.3  The queue: @ps, @wait, and @halt. HALT flag
 4.4  Decision making: @switch
 4.5  Other ways of triggering: @use and @startup
 4.6  User-defined commands:  $command, @scan, @verb
 4.7  Introduction to functions: ADD() and other math, RAND(), TIME()
 4.8  Do it!  --  falcon control

Section III: Programming applications

5. Vehicle programming
 5.1  Entering and leaving objects: @enter, @aenter, @oenter, @oxenter,
      @leave, @aleave, @oleave, @oxleave
 5.2  Inside vehicles: @idesc, @listen, relays, and commands, @remit,
      AUDIBLE, @prefix, @filter, @forwardlist
 5.3  Do it!  --  Wagon controller
6. Complex programming
 6.1  Useful functions:
         General use: NUM(), LOC(), NEARBY()
         List creation: LCON(), LEXITS(), LWHO()
         Parsing: POS(), FIRST(), REST(), STRLEN(), MID(), WORDS()
         Matching: EXTRACT(), MATCH(), MEMBER(), UCSTR(), LCSTR(), CAPSTR()
 6.2  Non-standard attributes: & and attribute flags
 6.3  Introduction to @dolist
 6.4  Time synchronization: semaphores, complex @wait, @notify, @drain
 6.5  Security problems in programming, INHERIT, ESCAPE(), and SECURE(),
         @fsay, @femit, @fpose
 6.6  Debugging: PUPPET and VERBOSE
 6.7  On the New Programming Style
7. MUSH Programming: QuickStart Guide
 7.1  Basic syntax
 7.2  Conditional and loop constructs
 7.3  Functions


Section IV: A Guide for Administrators

8. Owning and seeing everything
  8.1  Special privileges, ROYALTY, and Powers
  8.2  Attribute ownership - @atrchown and @atrlock
  8.3  Object ownership - @chown and @chownall
  8.4  The queue - @ps and @allhalt, @kick
  8.5  The database - @entrances, @find, @search, and @stats
  8.6  A note about security and privacy
  8.7  The Master Room and command processing
9. Wiz-specific commands
  9.1  Talking to other wizards: @wizwall and @wizemit
  9.2  Messages: @wall, @listmotd, @motd, and @wizmotd
  9.3  Locking out players: @login and @rejectmotd
  9.4  Dealing with players: @newpassword, @pcreate, @boot, @toad, and @destroy
  9.5  Dumping the database: @dump and @shutdown
10. Database control
  10.1  Quota system: limited object creation - @allquota, @quota, and @squota
  10.2  Money control: give and @poor
  10.3  Consistency checking: @dbck and @purge, @dump/paranoid, @cut, @fixdb
11. Zones
  11.1  Object zones
  11.2  Parent room zones
  11.3  ZoneMaster players
  11.4  Some notes on local wizard control
12. The Fundamental Laws of Wizarding
  12.1  Wizard Etiquette
  12.2  The Five-Step Method of player management
          warning - nasty warning - gag - boot - newpassword
  12.3  Wizard commands and when they ought to be used

Section V: The Art of Psychocoding
13. Basic Concepts
  13.1  Attribute naming and coding style
  13.2  String concatenation and the switchless style
  13.3  What the parser really does
  13.4  Zones in TinyMUSH 2.2
14. List manipulation
  14.1  Adding to, removing from, and comparing lists
  14.2  Function building blocks: U() and SWITCH(), @function
  14.3  Formatting strings: SPACE(), REPEAT(), LJUST(), and RJUST()
  14.4  Lists instead of @dolists: ITER() and FILTER()
  14.5  Recursion: theory and practice, FOLD()
15. Efficiency
  15.1  Parameter passing: U(), ULOCAL(), local registers, SETQ(), and R()
  15.2  How the queue works
  15.3  Pipelining
  15.4  Queue cycles vs. CPU cycles

-----------------------------------------------------------------------------


This is the table of contents for Amberyl's MUSH manual. She can be
found on PernMUSH, or at lwl@netcom.com. This manual should be current
through TinyMUSH version 2.2.1, and PennMUSH version 1.50 patchlevel 12.
Much of it should also apply to TinyMUSH version 2.0.10 patchlevel 5
(from which TinyMUSH 2.2 is derived). Differences between the two
versions will be noted where necessary; in general, 2.0 will refer to
features common to both 2.0 and 2.2, and 2.2 will denote features
specific to 2.2. Do note that because 2.0.10p5 is now an obsolete
version, and 2.0.10p6 is not much more advanced, that there may be
sections of this manual which simply do not function under those
code versions, or which require modification (for example, 2.0.10p5
does not have the %q-substitution, though it does have the R() function).

This manual version also covers commands that are softcoded in MUSH,
found in the MUSHcode starter database called MudCore. MudCore global
commands are found on a variety of MUSHes, most notably PernMUSH and
AmberMUSH; it is convenient to mention them in this manual, since
many tasks can be simplified by use of these globals, and even those
MUSHes that don't use MudCore or the equivalent do have globals which
perform similar functions.

The 2.0x manual series is a complete rewrite using the 1.15 manual as
a starting base. Unlike the previous manual, this one is intended to
replace anything that has come before, including Croaker's manual,
which is pretty much obsolete for this version of code.

Those programming MUSE should probably look at the 1.15 manual release
instead, or use Falryx's MUSE Manual, which is based upon this manual
(with permission). The MUSE parser is quite close to the original 1.x
parser, and the basic examples in this manual should work without any
problems. The MUSE powers system and related issues are beyond the
scope of this manual (and the author's knowledge, for the most part);
the helptext for MUSE and consultation with a MUSE programmer are
probably the best ways to figure out how to program MUSE.

TinyTIM players may still find Croaker's manual helpful. There is also
a TinyTIM supplemental manual, since TIM has diverged quite a bit from
the "mainstream" MUSH. The contents of the PernMUSH 1.15 manual and
this manual may or may not apply to TinyTIM. The parser on TIM,
however, is fairly similar to the standard 1.x parser. There is,
however, probably little of interest in this manual for the TinyTIM
player, since most of the features mentioned here do not exist on TIM.

This is the tenth revision of this manual. There have been some major
revisions in the servers since the prior revision, though these
primarily affect advanced programming techniques and administrative
commands. This manual only documents the most important of these; for
the rest, the helptext should suffice.

I have also corrected a number of previous errors, and further
expanded the notes on advanced programming techniques, which seem to
be in great demand. There are also a number of formatting changes,
which, in my opinion, make the text easier to read. A fair amount of
the text has been expanded (and hopefully clarified); I've also chosen
to introduce more "advanced" programming techniques earlier in the
manual. Finally, I've taken the opportunity to explicitly debunk a few
myths about MUSH programming, as well as provide specific methods for
things that I often see programmed incorrectly or inefficiently.
There are a lot of small changes, and a few sections added and
removed. The structure of this manual is slowly becoming obsolete,
due to the changing methods of MUSH programming, and, specifically,
learning to program MUSH; it is likely that future revisions of the
manual will restructure substantial portions of the text.

The tenth revision is also the first version of the manual to document
a softcoded package of MUSHcode, in this case, the MudCore Starter
Database. I regard the standardization of certain core pieces of
softcode as something which will ultimately make the transition from
one MUSH to another much easier, and thus I'm going to attempt to
support a standard by placing it in the manual. MudCore is slated
for an early-summer 1995 release; portions of it can be found on
games such as PernMUSH and AmberMUSH.

The ninth revision of the manual was relatively minor, correcting
previous mistakes, expanding various bits of material, attempting to
clarify the somewhat confused earlier explanation of semaphores, and
adding additional material on advanced programming topics.

The eighth revision of the manual was the first to cover advanced
programming, in a newly added section. The rest of the manual,
however, is not meant to be a guide to advanced programming, nor does
it necessarily show the "best" way to do something. It is intended to
show the most intuitive and basic way to get something done in MUSH.
It is also not a complete guide to MUSH; for that, you need to look at
the helptext. This manual is meant to act as a tutorial and as a
pointer to some of the more useful things available in MUSH, as well
as to clarify some of the things that are not easily covered in the
helptext. For the precise syntactic details on a command, look up the
help text; especially in the latter sections, this manual attempts to
avoid duplicating material found in the help, concentrating instead on
techniques and details.

The final "advanced programming" section of the manual convers the
"new" style of MUSH programming, which relies heavily on list
manipulation functions and string concatenation to produce the desired
result. This is commonly referred to as the "switchless style". While
I believe this is something best learned on one's own, an overview of
the common techniques is presented here. It also includes a discussion
of how to write programs that are efficient in their use of queue
cycles, without overburdening the server itself with very large,
complex function evaluations.

If you spot any errors in the manual, PLEASE send me email. You should
mention the specific MUSH version you are using, and mention as
specifically as possible where the error is.

Finally, by way of thanks to the various people who have, in the past,
contributed examples/typo reports/etc. to this manual, I've thrown
their names in as player examples in various places. I hope they enjoy
their brief moment of fame.

A "README.mushman" file accompanies this manual distribution,
and must be retained with any electronically-retrievable version of
this manual. To summarize the copyright notice contained therein:

This manual was written by Lydia Leong (lwl@netcom.com), and any
rights and privileges of reproduction are hers, in accordance with
United States or international Copyright Laws. Users are granted
permission to print and reproduce this manual in its unmodified
entirety, as long as this copyright notice is retained and due credit
given, and the material remains free of charge. It can be quoted, with
credit, within the bounds set by standard academic protocol. It may
NOT be used within another major document (such as another manual),
nor published in print form (whether or not the publisher makes a
profit from such publication), nor may it be hypertextified or
otherwise changed in format, without the explicit permission of the
author.


     --  Amberyl, May 22nd, 1995

MUSH Manual Version 2.008:
   Copyright 1993, 1994, 1995, Lydia Leong (lwl@netcom.com / Amberyl)
   Last revised 5/22/95.

Section I: Getting Started. Basic commands and objects.

Table of Contents:

Introduction: A brief history of MUSH. Configurations and server differences.

1. The Basics
 1.1  Some information
        Common terms used on MUSHes.
        The format of this manual.
 1.2  Getting started
        Looking around: look, examine, @decompile, TERSE, MYOPIC, @grep
        Communications: ", :, @emits, page, whisper, basic flags and @set,
           HAVEN, GAGGED, NOSPOOF
        Going places: JUMP_OK, @tel, @whereis, UNFINDABLE
        Objects: get, drop, give, ENTER_OK, inventory
        Command syntax, @set and flags, special commands, @list
 1.3  Attributes: @desc, @succ, @fail, @drop, @kill, IMMORTAL, @move, @sex
 1.4  Editing: @edit, @mvattr, @cpattr
 1.5  Do it!  --  basic character set-up
 1.6  A parser discussion
2. Objects
 2.1  Basic object commands: @create, @destroy, @force, @name, VISUAL
 2.2  Puppets - the PUPPET flag. ROBOTs.
 2.3  A Note about Privacy: @sweep
 2.4  Attributes on Objects: Action Lists, @decompile, the parser
 2.5  Machines: @cost, @pay, and @clone, QUIET and DESTROY_OK flags, @parent
 2.6  Limiting object uses: @charges and @runout
 2.7  Reacting to the environment: @listen and @ahear, ^, LISTENER/MONITOR
 2.8  Keeping your objects safe: @lock, @unlock, @chown, CHOWN_OK, STICKY,
         @search, @find, @stats
 2.9  Do it!  --  falcon

INTRODUCTION:

MUSH is a derivative of the original TinyMUD. In general, a MUSH is a
place where players can hang out, socialize, program, and build. There
are nearly four dozen public MUSHes running at the time of this
writing. Most MUSHes use variants of either the PennMUSH 1.50 or
TinyMUSH 2.0 servers (TinyMUSH 2.2 is derived from TinyMUSH 2.0);
although behavior for all MUSH versions should be similar, code
patches and unofficial modifications are very common, so what works on
one MUSH won't necessarily work on another. This manual describes the
"standard" behaviors for the official MUSH versions.

MUSH looks very similar to the text adventure games that were popular
in the mid-1980s. The difference between a MUSH and an Infocom game is
the crudity of the parser, the user-extendibility, and the
multi-player capability of the former. The programming language of
MUSH is most similar to LISP, in its emphasis on lists and the way
functions are evaluated.

The MUSH code dates back to spring of 1990, or so. The only presently
surviving MUSH from that era is TinyTIM. Somewhat later came
MicroMUSH, and TinyCWRU. All three were based off the original
TinyMUSH, which was a heavily modified TinyMUD, done by Lawrence
Foard.

In January of 1991, PernMUSH was started, using MicroMUSH code as a
base. Moonchilde began to distribute PernMUSH code a little while
later, while MicroMUSH became MicroMUSE. In the spring, the 2.0
rewrite project was started. MUSH had become a messy collection of
hacks, and most of them were non-standard; JT Traub (Moonchilde of
PernMUSH), Glenn Crocker (Wizard of TinyCWRU, Dave Peterson (Evinar of
TinyDungeon), and some other programmers got together to completely
rewrite the MUSH code.

"Vanilla" MUSH code - the unadulterated original by Larry Foard - is a
relic of the past; the MicroMUSH code off which PernMUSH is based has
also essentially disappeared. TinyTIM has never distributed its code,
and is significantly different from the other existing MUSH
codes. These three MUSH versions, therefore, are not covered in this
manual.

PernMUSH switched to 2.0 code in November of 1991. The 1.x code
fragmented into three versions - Spellbound, based off PernMUSH 1.13,
SouCon, based off PernMUSH 1.14, and PennMUSH, based off PernMUSH
1.15, Moonchilde's final distribution. Only the last still exists, and
it was the only one of the three versions to be publicly distributed;
the name was changed to "Penn" to avoid confusion, since PernMUSH
itself switched to using 2.0 (and now, 2.2).

In the fall of 1994, a number of wizards from large MUSHes got
together to discuss the difficulties of TinyMUSH 2.0. TinyMUSH 2.0
releases over the past year had been, by and large, fairly buggy, due
to lack of testing in a "production MUSH" environment (one open to
large numbers of players). Furthermore, gripes about the bugs
introduced with new "features" resulted in the virtual end of
development of new features. It was decided to begin work on a server
development project, called TinyMUSH 2.2 (there had been an aborted
TinyMUSH 2.1 project which attempted to use the UnterMUD OIF format
for a database). TinyMUSH 2.2 is more a continuing of TinyMUSH 2.0
development than an actual new server. It is the pet project of Jean
Marie Diaz (Ambar of PernMUSH), Devin Hooker (Tyleet of Two Moons),
and Lydia Leong (Amberyl of PernMUSH), in conjunction with a number of
other helpful people. Every reference to TinyMUSH 2.0 in this manual
also applies to TinyMUSH 2.2, unless specifically stated otherwise.

This manual is being written specifically for the PennMUSH 1.50 and
TinyMUSH 2.0 / TinyMUSH 2.2 code releases, currently available via
mellers1.psych.berkeley.edu, caisr2.caisr.cwru.edu, and
ftp.cis.upenn.edu, respectively. Should you wonder at the references
to dragons and similar objects throughout this manual, realize that
the examples were originally written to fit the world of PernMUSH,
presently located at astral.magic.ca 4201; as this manual has
evolved, other examples from other worlds, such as The Belgariad (once
at csa.bu.edu 4201) were thrown in, together with more generic
objects.

If you're trying to program any flavor of MUSH besides TinyMUSH 2.x,
or a MUSH version earlier than 1.16, you are better off getting
the version 1.15 of the Pern manual (mushman.1.15.shar.Z, probably
located at the same place you got this manual). This manual is more
detailed than that one; it is intended to cover MUSH programming
extensively. I have tried to make the examples useful; if you work
through the manual's Do It! sections, whether or not you completely
understand them, you should have some rooms built for a house, a
falcon, a vehicle, and some assorted other useful objects.

Please note that the 2.0 examples in this manual assume that your MUSH
has a certain set of "common" aliases and command options. TinyMUSH
2.0 is highly configurable. If something doesn't work, or works
differently from the way it is described in this manual, chances are
that the configuration is different. The command "@list options" lists
many of these options.

Differences between 1.50 configurations are generally less visible,
and generally only affect the way things are displayed, or the
internals of the server, instead of directly changing the behavior of
a command (for example, whether @switch matches all cases or just the
first one).

There are three major mailing lists set up for MUSHers. They are:
tinymush-programmers@cygnus.com (for MUSH programmers and general
users), mushhacks@caisr2.caisr.cwru.edu (server hackers for TinyMUSH
2.0), and pennmush@med-itvax1.bu.edu (server hackers for PennMUSH
1.50).  To join one of the lists, mail <list name>-request@sitename
with a subscription request (i.e., to join mushhacks, send email to
mushhacks-request@caisr2.caisr.cwru.edu).

   --  Amberyl (lwl@netcom.com)

---------------------------------------------------------------------------

1. The Basics

1.1	Some information

These are terms which are in common use and which you should know:

Player: the person who is reading this manual.
Character: the virtual-person who wanders around the MUSH under the control
	of the player.
Puppet: an object that is under the control of a character, who can see and
	perform actions of its own.
Robot: something which appears to be a character, but is actually an
	external program, usually written in C or LISP, which, when run,
	connects to a remote computer and pretends to be a player. Some are
	quite sophisticated. This word is also used to refer to objects which
	are programmed, using MUSH code, to behave like players, or to perform
	a specific function, like deliver mail. Sometimes robots will be
	referred to as 'bots.
Machine: Objects which are programmed to do certain things, like dispense
	mugs of klah, or repeat the word "Die" every five minutes, or any one
	of a thousand different possibilities. The second type of robot
	mentioned above is a type of machine.
Flag: Something which controls behavior of an individual object. It can
        be either on or off, and usually affects the kind of output the
        object sees/gives. The '@set' command is used to turn a flag on
        or off on a particular object. A frequently used terminology in
        this manual is "<object> is [not] set <flagname>".
        "Joshua is set OPAQUE" simply means that 'Joshua' has the 'OPAQUE'
        flag set on himself (i.e. it is turned on).
Object Type: Objects are classified into one of four types: PLAYER, THING,
        ROOM, or EXIT. A 'player' is something which can be connected to
        via a name and password, who can own things and functions
        independently of anything else in the game. A 'thing' is a mobile
        object, which can be picked up, dropped, and manipulated in various
        ways. An 'exit' is a link which connects two locations in the game.
        These locations are normally known as 'rooms'. (You can be inside
        a thing, too, but a 'room' is the basic unit of building).
        In this manual, 'object' and 'thing' are sometimes used generically
        to refer to objects of any type.
Dbref: Every object in the database is assigned a number, called a
        "database reference number", or "dbref" for short. A hash sign
        normally prefixes a dbref, i.e., "#100". The dbref is the object's
        unique identifier (unlike its name, which could be the same as
        that of many other objects).
Client: a program which replaces telnet. Clients are designed specifically
	to connect to MUDs, and frequently provide many features that are not
	available with ordinary telnet, such as macros, logging, hiliting,
	and the ability to switch between several worlds very quickly. Two
	popular clients are TinyTalk and TinyFugue. The latter is an improved
	version of the former. Both run under UNIX.
Mark: the unit of currency on Pern. Other places use Pennies, Credits,
	Dollars, or even Cookies. The cost of an action varies from nothing to
	100 Marks, for commands which are computationally expensive. Players
	normally get a certain amount of money every day.
God: the person who is, overall, in charge of the MUSH. He is generally
        responsible for code maintenance and general order. He has powers
        not available to anyone else, and may not be @forced by anything.
Wizard: a game administrator, picked by God to help run the game. Wizards
        control all objects, and have special commands available to them.
        Wizards cannot hear things that ordinary players cannot.
Royalty: a game administrator, a kind of "sub-wizard". Royalty can see all
        objects as if they controlled them, but cannot change them.
Mortal: a non-wizard, non-royalty player.
Control: Every object in MUSH is controlled by one or more things. Players
        always control the objects they own. Wizards control everything.
        There are other ways to control objects; these will be explained
        later.

Commonly used abbreviations:
  IMHO: In My Humble (or Holy) Opinion
  RL: Real Life. The world outside MUDs.
  VR: Virtual Reality. The MUD world or worlds.
  OOC: Out of Character. Used when the player rather than the character
       is the one speaking, such as when a dragonrider character on PernMUSH
       wishes to comment on the features of the latest SPARC station.
       The opposite of this is 'IC' -- 'In Character'.
  LOL: Laughs Out Loud.
  ROTFL: Rolls On the Floor Laughing.

Now that the definitions are out of the way:

Examples in this manual will be set off by  [ Example Number ] at the
beginning and = signs around the example. Words that appear in <  >
aren't supposed to be typed in literally. For example, if I use
"<your name>", don't type that, but type your name instead. In examples,
lines that begin with "> " indicate something that I've typed in.
Words that appear in [ ] are optional; for example, if I use
"examine[/brief]", you could either type "examine" or "examine/brief".
Everything else is the MUSH's response. The 'main character' used in the
examples is Elsa, on PernMUSH. Various other characters are used as
props throughout the manual; most of them are PernMUSH players who have
contributed in some way to this manual and are thus being immortalized
by way of thanks.


1.2	Basic Commands

Looking around:

The "look" command (abbreviated "l") allows you to look at your
surroundings. "Look" by itself shows you the description of the room
you are in. "Look <object or exit>" shows you the description of that
object or exit. You may specify a thing by its name, its dbref number,
as *player, or as "me" or "here". "Read" is identical to look in all
respects.

Possessive "look" allows you to look at something that someone or
something is carrying. The syntax is just: "look <object>'s <thing>".
You cannot look at someone's inventory if they are set OPAQUE or DARK.
(OPAQUE and DARK are flags, and will be explained in more detail
later.)

You automatically "look" at every room you enter. If you are trying to
move rapidly through familiar areas, you may want to set yourself
TERSE.  This flag suppresses room descriptions and room success/fail
messages; the MUSH will display only the location name, its contents,
and the obvious exits.

The MYOPIC flag prevents you from seeing the dbref numbers and flags
on objects that you control. If you like your output "pure", you may
wish to set yourself MYOPIC.

* * * * *

The "examine" command (abbreviated "ex") provides more detailed
information about an object. If you do not control the object, this
command will tell you who the object is owned by, and (in some
configurations) show you any public attributes on that object, such as
the desc, sex, and "last" connect time. If you are in the same room
with the object, and the object is neither DARK nor OPAQUE, you are
also shown the list of all its non-DARK contents, and any non-DARK
exits. You can also use "examine/brief" to see just the owner's name.

1.50 has the "brief" command. This is like "examine", except
that brief shows all object information EXCEPT for attributes.

In 2.0, if the config directive "examine_public_attrs" is on,
normal players will trigger the looked-at object's adesc when they
examine/full the object, if the object is in the same room. Wizards,
however, do not trigger this.

If the object is not in the same room, you do not control it, and the
"examine_public_attrs" config directive is off, you will see <Too far
away to get a good look> instead of the description, and cannot get a
contents list, although you will still see other public attributes and
the owner's name.

If you own the object or the object is set VISUAL, examine will show
you the full list of attributes on the object, and other properties on
it.  To see a specific attribute, "examine object/attribute".

You may use wildcards - * and ? - in examine, to match a group of
attributes. The '?' wildcard matches any single character (but must match
at least one character); the '*' wildcard matches any number of characters
(including "none"). For example, "examine object/v*" would show all
attributes on an object whose names begin with v. "examine object/???"
would match those attributes whose names are exactly three letters long.
"examine object/a?*" would match those attributes whose names are at least
two letters long and begin with 'a'.

In 1.50, if you are set ANSI, the names of attributes and the dbref of
their owners will be hilited in boldface. This makes the boundaries
between attributes clearer, preventing large MUSHcode objects from
looking like several pages of random characters.

* * * * *

In 1.50, the @grep command can be used to search for a certain
pattern on an object. Doing a "@grep <object>/<attributes> = <pattern>"
prints a list of all attributes on <object> which contain text matching
<pattern>. This <pattern> may contain wildcards. <attributes> is a
possibly wildcarded pattern of attributes to match (like that for "examine"
above). If you merely do "@grep <object>=<pattern>", the game assumes
that you want to search all the attributes on <object>.

@grep can take one of two switches, "list" or "print". The default is
"list", which just returns the list of attributes that match the
pattern.  The "print" option can only be used if you are set ANSI. It
prints out all the attributes which contain the pattern, hiliting the
text which matches the pattern in boldface.

MudCore provides a similar command, called +grep. This performs a
similar task, though it only prints out the list of attribute names
that contain the pattern, rather than printing out the attributes
themselves. The syntax is, "+grep <object>[/<attributes>] = <pattern>".

MudCore also provides another useful command for listing the attributes
on an object, called +lattr; it displays the attribute names, and the
first line of text in that attribute. The syntax for this is,
"+lattr <object>[<attributes>]". The command also takes several
switches, which restrict the attributes displayed to those of certain
types (attributes which are $commands, ^monitors, globally-defined,
or none of the above).

* * * * *

The "@decompile <object>" command, when executed on an object that you
own, outputs the sequence of commands you would need to type in order
to duplicate that object. It may be used on any type of object.

@decompile is very useful for creating files which can be uploaded
onto another MUSH. To combine @decompile with TinyFugue, use the
following sequence of commands (presuming you want to save an object
called "Test" to a file called "testfile", and then upload it to
another MUSH called "NewWorld").

/wrap off             [ in TinyFugue 3.0 and later:  /set wraplog 0 ]
/log testfile
@decompile Test
/nolog
/world NewWorld
/quote 'testfile
/wrap on              [ in TinyFugue 3.0 and later:  /set wraplog 1 ]

This sequence does the following:

1. Turn off wordwrap so extra newlines aren't inserted into the output.
2. Save MUSH output to a logfile.
3. Decompile the object.
4. End saving of MUSH output to a logfile.
5. Log onto a new MUSH.
6. Upload the object to the new MUSH.
7. Turn wordwrap back on.

This method allows you to easily transport objects across MUSHes.
Also, if the game should unexpectedly crash, or the database gets
corrupted, or some other disaster occurs which causes you to lose the
original copy of the object, all you have to do is upload it
again. You should always try to @decompile any objects that are
especially valuable to you, and store them off-line, in case of
such a disaster.

			----------

Communications:

You can speak using "say <message>", or by typing a double quote
followed by the message (with no space after the "). Your name and the
word "says" will be appended to the beginning of the message. A
trailing " will be automatically added to the end of your message;
don't type one in.

You can pose (emote) using "pose <action", or by typing a colon
followed by the message (i.e., ":<action>"). Your name and a space
will be automatically added. If you want to avoid the added space, use
"pose/nospace <action>", or a semi-colon followed by the message
(i.e., ";<action>"), or a colon followed by a space and then the
message (i.e., ": <action>"). This is useful for doing possessives and
similar things.

In 1.50, most messages like "<person> <speech action> <message>" will
include a comma - i.e, 'Annalyn says, "Hi."' or 'Annalyn whispers, "Hi."'
In 2.0, this comma is missing, for historical reasons.

* * * * *

In 1.50, if you want to send a private message to yourself, you
can "think <expression>". Pronoun substitution and function evaluation
is performed. The equivalent command for 2.0 is "@pemit me=<expression>";
you can achieve a similar effect with "@pemit/silent me=<expression>"
in 1.50, but "think" is easier to type.

There will be many times when you wish to communicate privately.  The
commands "page" and "whisper" (abbreviated "p" and "w") are used for
this, as in, "page <person>=<message>" or "whisper <person>=<message>".
Whisper sends a private message to a person who is in the same room as
you. In certain configurations, people in the same room also see that
you whispered something to that person; most MUSHes, however, do not
use this "noisy" form of whisper. The page command sends a private
message to a person on the MUSH; you can use it to talk to someone in
a different room. The cost of page varies from MUSH to MUSH.

You can whisper and page poses to people, by using a ":" in front
of your message. If you whisper a pose to someone, you are told,
"<Person you posed> senses "<Your name> <pose>".  The person sees,
"You sense <Person who posed> <pose>". If you page a pose to someone, you
are told, "Long distance to <Person you paged>: <Your name> <pose>"
The person sees, "From afar, <Person who paged> <pose>".

Partial name-matching is performed on "page". You only have to type
as many letters of the name as needed to distinguish it from the other
players connected (for page) or the things in the room (for whisper).

"Lastpage" is supported in 1.50; to send a message to the person that
you last paged, type "p =<message>" or "p <message>". "p" by itself
will tell you the name of the person whom you paged last. Try to be
careful with this, since it's easy to mis-type when trying to page
someone different and accidentally sending the message to the wrong
person (this happens a lot when people substitute '-' for the '=',
accidentally).

There are two ways to block pages in 1.50. The HAVEN flag, when
set on a person, prevents them from receiving pages or @pemit *player
messages. Alternatively, the use of a page lock prevents those who do not
pass the lock from paging the player. Anyone who pages a HAVEN player is
told, "That player is not accepting any pages."  Anyone who fails the page
lock will be told, "That player is not accepting your pages."  If the target
player has a @haven attribute set, the message in that attribute is sent to
the paging player. The HAVEN player does not receive any notification that
someone tried to page him.  See the section on locks for instructions on
how to set a page lock.

In 2.0, only page locks can be used to block pages. Players who fail
the page lock will be told, "That player is not accepting pages.", or,
if the target player has a @reject attribute set, the message in that
attribute.

Specifically, to prevent a single person from paging you, use,
"@lock/page me=!*<player>". To prevent everyone except a single
player from paging you, "@lock/page me=*<player>". To prevent
everyone from paging you, "@lock/page me=#0".

If you set an @idle attribute on yourself, anytime someone pages you,
they will have that idle-message sent to them, and you will be
notified that they have received it, together with a timestamp. This
is very useful if you are unexpectedly called away from the keyboard
and want to know when people paged you, while politely notifying them
that you aren't there.

If you sent an @away attribute on yourself, if someone tries to page you
when you aren't connected, they will receive that message. Customarily,
this is used to tell people where you might be, when you will be back,
and where you can be contacted.

* * * * *

The GAGGED flag, when set on a person, prevents him from doing
anything but moving and looking. This flag may only be set by wizards,
and is used as a punishment for players who are being particularly
obnoxious.

Related to GAGGED is the SLAVE flag. It prevents the player from using
any commands that change the database. It may only be set by wizards.

Flags will be explained in more detail later.

* * * * *

The "emit" family of commands prints things without any name
prepended. This is handled by switches (the basic command name is
followed by a slash and the switch name) added to the commands @emit,
@oemit, and @pemit. In 1.50, and in many configurations of 2.0, these
command-switch combinations are aliased to shorter commands.

The basic command is "@emit <message>". The message will appear
exactly as you have typed it. Everyone in the room, including you,
will see the message.

In 2.0, normal "@emit" is shorthand for "@emit/here". An alternative
way of doing emits is "\\<message>". There should be no space between
the "\\" and the message. Also, two "\"s are necessary because \ is
used as an escape character.

@emit has another switch, "room". "@emit/room" is often aliased to
"@lemit". It shows a message to the outermost room you are in (the
"absolute room"). For example, if you are in a chair inside a wagon
inside a room, and you perform this command, the message is shown to
the room, not to any of the intermediate objects. There is a limit of
twenty intermediate layers.

Related to the @emit command are @pemit and @oemit, and their
variations.  "@pemit <player>=<message>" will emit a message to a
single person. If the person is in a different room, you must use
"@pemit *<player>=<message>". In 2.0, this normal @pemit is shorthand
for "@pemit/object". In 2.0, you are not told when you @pemit to
someone; certain configurations of 1.50 will notify you that you
@pemit'ed the message. In those configurations, using @pemit/silent
will eliminate the notification.

"@oemit <player>=<message>" will emit the message to everyone in the
room the @oemit'ing object is in, except the named player.  1.50 also
permits "@oemit <room>/<player>=<message>", which emits the message to
everyone in <room> but <player>; the @oemit'ing person must control or
be in <room>. This latter form of the command is somewhat unnecessary,
and thus non-existent, in 2.0; if it can locate where the named player
is, the message will automatically go to that room.

"@pemit/contents <object>=<message>" will emit a message to everyone
in a room or container object, as well as to the container
itself. @pemit/contents is generally aliased to @remit.  The <object>
is generally a dbref number or *player; if the object is a player,
@remit to that player will show the message to all that the player is
carrying, as well as the player himself. Note that @pemit without the
/contents switch does not show a message to anything a player is
carrying, unless the player is set with a @listen attribute of "*".

"@pemit/list <list of dbrefs>=<message>" will emit a message to a list
of objects. These objects must be specified by their dbref numbers.
This version of the command may also be combined with the /contents
list, to send a message to several rooms.

@emit, @pemit, @oemit, and @emit/room do not prepend the name of the
player using the command. If you want to see where these @emit
messages are coming from, you should set yourself NOSPOOF.

In 2.0, NOSPOOF tells you the origin of any output that did not
originate with you, directly or indirectly (i.e. you or an object that
you @forced). If the origin is a player, "[PlayerName(#dbref player)]"
will be prepended to the message. If the origin is an object,
"[ObjectName(#dbref object){PlayerName}<-(#dbref forcing object)]"
will be prepended by the NOSPOOF indicator. The forcing object may
be a controller object, the player himself, or a wizard. It is the
object which caused the command to be executed.

In 1.50, NOSPOOF tells you the origin of any type of @emit, whether
or not you or one of your objects is responsible for it. It prepends
"[<object name>]" to the output (or, if the configuration directive
"PARANOID" is on, "[<object name>(<dbref number>)]")

In 2.0, the HAVEN flag does not block out any type of @emit, though
page locks will block @pemit and its relatives @pemit/contents
(@remit) and @pemit/list; in 1.50, the HAVEN flag blocks @pemit and
@remit to players. 1.50 page locks do not block emits of any sort.

			----------

Going places:

The @teleport command allows you to move to a different location
instantaneously. Two criterion have to be passed in order for you to
be able to teleport to a location: you must pass the room's teleport
lock, and the room must either be JUMP_OK or controlled by you.  You
can teleport to a location by using "@tel <room number>".  You can
teleport objects that you own, using "@tel <object>=<room number>". If
you have an unwelcome guest or object in a room that you own, you may
teleport that thing to any JUMP_OK location. You may also teleport the
thing to another room that you own or through an exit that you own.

In 1.50, and older versions of 2.0, you can find out where a player is
with the command "@whereis <player>". The player will be told, "<Your
name> has just located your position."  @whereis will give you the
name of the player's location, and, if the room is JUMP_OK or is
controlled by you, the number of the location. If you can teleport to
that room, you can go to the player by using "@tel loc(*player)".

Some people find being "@whereis"'ed annoying. Generally, it is rude
to "@whereis" people that you don't know, or to "@whereis" them
without following up with a page message of some sort, explaining why
you wanted to know their location.

Players can prevent others from finding out where they are by setting
themselves UNFINDABLE. In this case, the locating player is told,
"That player wishes to have some privacy."  and the player who is set
UNFINDABLE is notified, "<Your name> tried to locate you and failed."

The UNFINDABLE flag can also be set on rooms. Anything inside an
UNFINDABLE room cannot be located by mortals. Paranoid players and
those having super-secret meetings may like this flag.

Sometimes, there are objects in a room which you may wish to enter,
such as a dragon. You can use "enter <object> to enter an object, provided
that you pass the enter lock on the object, and it is ENTER_OK or owned by
you.  In order to get out of the object, use "leave".  In 2.0, you must
pass the leave lock in order to do this.

You can put enter and leave aliases on objects. The words stored in
the @ealias and @lalias attributes on an object may be used in place
of "enter <object>" and "leave". For example, if a chair has the
@ealias "sit" and the @lalias "stand", "sit" may be typed in place of
"enter chair" and "stand" may be typed in place of "leave".  You can
use multiple aliases by making them semi-colon separated, like exits
are: "@ealias chair = sit down;sit;sit on chair" allows one to type
"sit down", "sit", or "sit on chair" to enter the chair.

			----------

Objects:

Picking up and dropping objects is easy - simply "get" or "drop" the
appropriate object. Possessive "get" also works - you can take from
something using "get <thing>'s <object>". The thing that you are
taking the object from must be ENTER_OK, and the object must not be
locked against you.  Also note that this applies to taking from
non-room objects in general; if you are inside a thing, you will not
be able to pick up obejcts inside of it unless it is ENTER_OK or you
control it.

You can give someone an object or money by using the "give" command,
i.e., "give <person>=<object>" or "give <person>=<amount of money>".
In 1.50, the person must be set ENTER_OK in order for them to receive
things.  In 2.0, the giver must also pass the recipient's ReceiveLock,
and the giver must pass the objects' GiveLock.

To get a list of objects you are carrying, do an "inventory"
(abbreviated "i"). This will show everything you are currently
holding, including DARK objects owned by other players.

			----------

Summary of command syntax:

The basic commands for looking, moving, etc. are few in number and
easy to remember. More complex commands, which generally are used to
change the database, begin with the "@" symbol.

Many commands have "switches" which change the meaning of the command
somewhat. "Examine" is one such command, with /brief and /full
switches. All commands with switches have a default. In 2.0, if a
command has more than one switch which are not mutually exclusive, you
may use several switches at once by doing command/switch1/switch2/etc.
1.50 also allows for switches, but you can only give one switch to a
command at a time.

Flags, mentioned repeatedly above, are used for a wide variety of
purposes. They are either on or off, with "@set <object>=<flag name>" to
turn one on and "@set <object>=!<flag name>" to turn one off.

Finally, three commands are extremely useful: WHO, LOGOUT, and QUIT.
The WHO command, for ordinary players, shows the list of all non-DARK
connected players, the time they have been on, the time since they
last typed a command, and their @doing, which is a short string set by
"@doing <message>". LOGOUT, which only exists in 2.0, disconnects a
player from a character, returning him to the login screen. QUIT
disconnects the player from the MUSH completely.

There is an inactivity timeout. If you idle too long, the MUSH will
disconnect you. The idle time allowed is generally one hour. It can be
found by doing a "@list options" in 2.0, and an "@config" in 1.50.  In
2.0, Wizards may change this value on themselves by setting their
@timeout attribute. Wizards who exceed the inactivity limit for
mortals are automatically set DARK. (In 1.50, this only occurs if the
Wizard is already set UNFINDABLE).

2.0's "@list" command can be used to find lists of all the commands,
flags, attributes, configuration parameters, options, command
switches, and other useful things. Typing "@list" by itself will give
the options. The closest 1.50 equivalent to "@list" is @config, which
outputs the important MUSH configuration parameters.

===============================================
[Example 1.2: Demonstration of Basic Commands]
> "Hi, everyone.
Elsa says "Hi, everyone."
> :waves.
Elsa waves.
F'jon waves back.
> ex/brief f'jon         [ 1.50: just plain "ex F'jon" ]
F'jon is owned by F'jon
> @emit The sun shines.
The sun shines.
> w f'jon=How are you?
You whisper "How are you?" to F'jon.
F'jon whispers "Fine."
> p jyrax=Hello.
You paged Jyrax with 'Hello.'.
Jyrax pages: Hello!
> @whereis Jyrax
Jyrax is at: Ramp of Ruatha Hold.
===============================================


1.3	Attributes

Attributes are places in an object where information can be stored.
The most common are the desc, succ, fail, and drop attributes. Each of
these have corresponding o- and a- attributes. For example, in addition
to succ, there are osucc and asucc. O stands for Other, and A stands for
Action. The name of the person who performed the action, and a space are
automatically prepended to the beginning of every O message. This person
is sometimes called the "enactor"; you will read more about enactors later
on in this manual.

The syntax for setting these and other standard attributes is
"@<attribute> <object>=<message>", as in "@desc me=A young woman."

"Desc" stands for Description. It is the message someone sees when they
look at something. An "odesc" is seen by everyone but the person looking
and the object being looked at. An "adesc" is the list of actions
executed by an object when it is looked at.

======================
[ Example 1.3a: Desc ]
> @desc me=Elsa is a slim young woman.
Set.
> @odesc me=looks at Elsa.
Set.
> @adesc me=:smiles.
Set.
[Now, if F'jon looks at me, he'll see: Elsa is a slim young woman.
 When he does that, Jyrax, who is also in the room, will see:
 F'jon looks at Elsa.]
Elsa smiles.
[Elsa's adesc forces her to do a pose, which is displayed to everyone,
 just as if she had typed :smiles. as usual.]
=======================

Note that many people find @odescs and @adescs rather irritating.  In
general, one should never use both (the above is for demonstration
purposes only). If you want to be notified that a person is looking at
you, one useful thing is: "@adesc me=@pemit me=%N just looked at you."
(or, in 1.50, "@adesc me=think %N just looked at you.")  The
abbreviation %N is explained in detail later; it means "eNactor Name",
and is the name of the person who triggered off the action.

Succ is short for success, and is the message seen by someone when
he successfully use something. Succ on an object is displayed when that
object is picked up. Succ on an exit is displayed when something walks
through it successfully. Succ on a room is displayed when someone looks
at it, under normal circumstances. An osucc is shown to everyone else in
the room, and an asucc is the action list taken when something is
successfully used.

======================
[ Example 1.3b: Succ ]
> @succ me=You lift up Elsa.
Set.
[ Now, when F'jon does a 'get Elsa', he sees, 'You lift up Elsa.'
  Elsa is now in F'jon's inventory, being carried around. ]
======================

Fail is short for failure, and is the message seen by someone when
he fails to successfully use something. Usually something fails to work
because it is locked. (Locks will be explained in detail, later).
Fail basically works like succ does.

Drop is seen by the person who drops an object. Odrop and adrop have
two uses: normally, they are performed when someone drops something, but
an odrop on an exit is shown to the people in the room that a person
enters (as opposed to an osucc, which is shown to the people in the room
that a person leaves).

===============================
[ Example 1.3c: Fail and Drop ]
[In the previous example, Elsa was picked up by F'jon. She's decided that
 she didn't much care for that, so she's going to take some action:]
> @lock me=me
Locked.
[This prevents anyone from picking Elsa up in the future.]
> @fail me=Elsa glares at you.
Set.
> @odrop me=drops Elsa, who looks rather irritated.
Set.
[Now, when F'jon types 'drop Elsa' he just sees "Dropped." since Elsa did
 not set a drop message on herself. Jyrax, however, sees: "F'jon drops
 Elsa, who looks rather irritated."  Elsa doesn't get any message, except
 for the description of the room she's dropped into.]
[F'jon tries to pick up Elsa again, but this time, she's locked, and
 'get Elsa' shows him the message, "Elsa glares at you."]
===============================


The @succ and @drop family of attributes is triggered in one
more case - when objects are given. The giver triggers off the @drop
family of attributes; the recipient triggers off the @succ family.

* * * * *

There is another attribute, kill, which is used when something is
killed. To kill something, use "kill <thing>=<money>". For every Mark you
spend, you have an additional 1% chance to kill the object. The default
cost of killing something is 10 marks. Spending 100 Marks always works.
Killing something halts it and sends it home, and pays it half the amount
of money that was used to kill it. It also triggers the @kill, @okill, and
@akill attributes (@death, @odeath, and @adeath in 1.50).

Killing is usually strongly discouraged. Certain things, like wizards,
cannot be killed. Objects with the IMMORTAL flag (or, in 1.50, with the
Immortal power) cannot be killed, but this privilege can only be granted
by a wizard.

* * * * *

The "move" set of attributes are used when something moves from one
location to another, no matter what the means of moving - going
through an exit, entering/leaving an object, going home, or
teleporting. The @move, @omove, and @amove attributes can only be set
on players and objects.

There is also a set of attributes specifically for messages sent when
a @teleport is done. The @tport, @otport, and @atport attributes are
used when you arrive at your new destination. The @oxtport works like
the @otport does, except the message is shown to the others in the
room that you just left. There is no @xtport or @axtport.

* * * * *

In 2.0, there are a large number of other attributes related to
succeeding or failing in attempts at various commands (usually related
to passing the appropriate lock). Only the "basic" form of the
attribute is listed in the table below; prepend "O" or "A" to it to
get the other forms.

@tfail:  failure in teleportation
@dfail:  failure to drop an object
@gfail:  failure to give an object
@rfail:  failure to receive an object when it is given

The only one of these which can easily be simulated in 1.50 is @tfail;
to get the effect of @tfail, use the "@efail" set of attributes.

* * * * *

The final attribute is not like the others. It's the sex attribute,
which is used for pronoun substitution, and lets you declare your gender.
The syntax is "@sex me=<male or female>". You don't have to make yourself
male or female, but it's strongly suggested. The gender "plural" is
also supported in 2.2, and modifies the grammar of messages appropriately.

There are more attributes, but these are the standard ones.  Certain
MUSHes may add their own global attributes, such as "EMAIL".  It is
also possible to make up attributes with arbitrary names, using "&" as
the beginning of the name rather than "@".  These user-named
("non-standard") attributes are described in greater detail later in
this manual; for now, just note that attribute sets of the format
"&<attribute name> <object>=<value>" are valid and set <attribute name>
on <object> with some text string <value>.


1.4     Editing

One rather useful command is @edit. This allows you to perform a
substitution on an attribute, so you can correct typos without having to
retype the entire thing. The syntax for this command is:
@edit <thing>/<attribute>=<old string>,<new string>

If <old string> is the character ^ by itself, <new string> will be
prepended to the contents of <attribute>. If <old string> is the
character $ by itself, <new string> will be appended to the contents
of <attribute>.

If commas, brackets, parentheses, percent signs, and other 'special
characters' appear in either string, curly braces { } must be used to
set each string off.

If <attribute> is a wildcard pattern, the @edit command does a
global replace for all attributes that match the pattern; for example,
@edit object/v*=a,b  would replace the letter a with the letter b
in all attributes whose names begin with v, in the object.

Certain types of patterns are extremely difficult to edit; these are
usually patterns which include the { or } characters, which are "special"
to @edit. Several methods exist to get around this problem; one is to
generate the string using edit(); the other is to take advantage of
some features of a client such as TinyFugue.

In TinyFugue, type, exactly as printed:

/def redit = /grab $(/recall %{0-1})

This command allows you to pull into your input buffer any number of lines
which could normally be obtained via the /recall command in TinyFugue.
This allows you to edit text that has already been displayed to you.

Therefore, to directly edit an attribute within TinyFugue, one can type,
"examine <object>/<attribute>" and then "/redit 1" to edit the text which
is then displayed.

* * * * *

To copy an attribute from one object to another, you can use:
@force me=&attrib1 object1=get(object2/attrib2)

It is also possible to copy attributes via a version of the @set command:
@set <new obj>=<new attrib>:_<old obj>/<old attrib>
This copies <old attrib> from <old obj>, setting it into <new attrib>
on <new obj>.

This somewhat clumsy method can be worked around by using a built-in
command -- @mvattr, and, in 1.50, @cpattr.

"@mvattr <object>=<old name>,<new 1>,<new 2>,<etc.>" will move an
attribute.  Moving an attribute always wipes it out. If you want to
copy the attribute, you must move it to itself as well, using
"@mvattr <object>=<old name>,<old name>,<new name 1>,<new name 2>,<etc.>"

In 1.50, there is, in addition to the @mvattr, a copy command:
@cpattr <obj>/<attr>=<obj1>/<attr1>,<obj2>/<attr2>,<etc.>
This copies <attr> from <obj> to <attrN> on <objN>. You can specify a
large number of object-attribute pairs (limited only by the MUSH
configuration, which is generally 100).  The original object-attribute
pair is NOT wiped out. Also, even if one copy fails (you specified a
non-existent object, or one that you don't control, etc.), the game
continues to try to finish copying to the other object-attribute pairs.

MudCore provides two alternatives: +cpattr and +mvattr.
"+cpattr <obj>/<attr> = <obj1>/<attr1> <obj2>/<attr2> <etc.>" is
more or less identical to the 1.50 @cpattr save in syntax.

There are two forms of the +mvattr command, one which moves one
attribute on an object, to another, and one which is used to move from
one object, mass groups of attributes which match a certain wildcard
pattern, to another object, keeping the attribute names the same:
"+mvattr <obj1>/<attr1> = <obj2>/<attr2>" does the first, and
"+mvattr <obj1>/<wildcard pattern> = <obj2>" does the second.


1.5	Do it!

Issue the following commands:
@desc me=<description>
@lock me=me
@adesc me=@pemit %N=<Your name> smiles and returns your glance.
@fail me=<message to show when someone tries to pick you up>
@sex me=<male or female>
@set me=enter_ok

You are now described, safe from robbery, and have a proper gender.
The adesc also allows you to see who is looking at you. (Don't worry
about the %N; it will be explained later). Also, since you are set
ENTER_OK, people can give you objects and money. One additional command
you may wish to issue is "@lock/enter me=me", which prevents people
from entering you.


1.6     A parser discussion

If you are completely new to MUSH, you may wish to skip this section
and come back to it later. Also, if you're programming 1.50 or 2.0
exclusively, you do not need to read this section, which explains
parser and game output differences between 1.50 and 2.0.

The command parsers for 2.0 and 1.50 are no longer significantly
different. Nested brackets, evaluation of the S() and U() functions,
and evaluation order should now be consistent.

There are some differences in messages between 1.50 and 2.0,
particularly in the building commands. Some of the more obvious ones:

@create:
  1.50   Created: Object <number>.
  2.0    <Object> created as object <number>
@clone:
  1.50   Cloned: Object <number>.
  2.0    <Object> cloned, new copy is object <number>.
@destroy:
  1.50   Halted.
         You get your 10 pennies deposit back for <object>.
         Destroyed.
  2.0    You get your 10 pennies deposit back for <object>.
         Destroyed.
         <Object> has left.

Errors in syntax are handled differently by the two parsers. Neither
parser reacts well to missing curly braces, brackets, and
parentheses. 2.0 in particular will often produce extremely garbled
output if matching is not correctly done; if you are getting output
from a 2.0 expression that begins with a large number of spaces and
ends with a group of right braces, brackets, or parentheses, you
almost certainly have a mismatch.  By contrast, 1.50 will generally
return the string up the point of the mismatch. This difference in
error handling should be noted by those attempting to debug code under
two different versions.

These differences, and some other minor cosmetic ones, will be
encountered frequently in the text of this manual. If you are using
1.50, please do not be alarmed at them.


---------------------------------------------------------------------------

2. Objects

Objects, for the purposes of this discussion, are anything which are
not rooms or exits. Players are very special kinds of objects, which
have rules and restrictions in addition to those normally imposed on
objects. Players cannot create other players (save for the wizard-only
@pcreate command, discussed later).


2.1	Basic object commands: @create, @destroy, @force, and @name

The syntax for object creation is "@create <object name>=<cost>".
If you do not specify a cost, the default is 10 marks. If you have enough
money, the MUSH will respond "<Name> created as object <#dbref>" and the
object will be placed in your inventory. You may refer to an object either
by its name, or by its object number. The MUSH parser performs name matching,
so after you create a Blue Tunic, for example, you can refer to it simply as
"Blue," unless you have a Blue fire-lizard with you. In that case, you
could use "Blue T" instead, or "Tunic."

You can change the name of an object with "@name <old name>=<new name>".
(This applies to things, exits, and rooms, not just things). Your name
can be changed by "@name me=<new name>" (1.50 requires, for player
name changes, "@name me=<new name> <password>").

The syntax for object destruction is "@destroy <objectname>".
@destroy may be abbreviated to @dest. In general, you may only destroy
objects that you own. It is important that you destroy objects once
you no longer need them, or they will clutter the database. MUDs have
a history of going down due to database bloat, so it is important to
try to conserve space. You will also get back whatever amount of money
it cost you to create the object.

If you want anyone to be able to destroy your object, you should set
it DESTROY_OK. This is useful for objects which are meant to be
temporary, such as messages.

If you want to avoid accidental destruction of an object, you should
set the object SAFE. This flag prevents the @destroy command from
being used on the object; instead, you must use @destroy/override
(@nuke). This overrides any protections on the objects, which include
the SAFE flag, wizard ability to destroy objects they don't own, and
wizard ability to destroy players.

You can make an object do something by using "@force <object>=<action>"
or "<dbref> <action>". The object behaves as if it had typed the
command. There are some restrictions on this, involving the INHERIT flag,
which will be explained later. Note that since the semi-colon character
is used to delimit commands, use of it in a @force will be considered
to separate different commands you want to force the object to do; if
this is not what you desire, you must surround the string with { braces }.

If you want someone else to be able to see the programming on one of
your objects, set it VISUAL. The other person can then "examine" it.

=======================================
[ Example 2.1: Basic object commands ]
> @create Test Object
Test Object created as object #8032
> i
You are carrying:
Test Object(#8032)
You have 168 Marks.
> drop test
Test Object has left.
Dropped.
> @force test=:bounces.
Test Object bounces.
> #8032 :rattles.
Test Object rattles.
> @set test=destroy_ok
Set.
> @destroy #8032
You get your 10 Mark deposit back for Test Object.
Destroyed.
Test Object has left.
=======================================


2.2	Puppets

Puppets are special objects which can hear and behave almost like
normal players. They are under the control of a player, and relay back
everything they see and do to that player.

Objects that have the KEY flag set cannot be picked up by puppets.
Exits set KEY cannot be used by puppets. In fact, more precisely,
puppets are treated as if they cannot pass any @locks that might be
set on those objects. This forces players to solve puzzles themselves,
instead of having their puppets do all the dirty work. In 1.50, the
KEY flag also causes objects to go home when the person carrying them
goes home or teleports.

=======================
[ Example 2.2: Puppet ]
> @create Test Puppet
Test Puppet created as object #8051
> @set test=puppet
Test Puppet grows ears and can now hear.      [2.2: "is now listening"]
Set.
> i
You are carrying:
Test Puppet(#8051p)
You have 168 Marks.
> drop test
Test Puppet>  Dropped.
Test puppet has left.
Test Puppet>  Elsa's Room
Test Puppet>  This is a small, sparsely furnished room.
Test Puppet>  Contents:
Test Puppet>  Elsa
Test Puppet>  F'jon
Test Puppet>  Obvious exits:
Test Puppet>  Out
Test Puppet has arrived.
Dropped.
> @force test=:squeaks.
Test Puppet squeaks.
> #8051 out
Test Puppet>  Corridor
Test Puppet>  A long, featureless corridor.
Test Puppet>  Contents:
Test Puppet>  Jyrax
Test Puppet>  Ball
Test Puppet>  Obvious exits:
Test Puppet>  Elsa's Room
> #8051 :squeaks.
Test Puppet>  Test Puppet squeaks.
> #8051 get ball
Test Puppet>  Taken.
Test Puppet>  Jyrax says "Hello, Test Puppet."
> @set #8051=!puppet
Test puppet loses its ears and becomes deaf.  [2.2: "is no longer listening"]
Cleared.
=======================

The puppet echoes back almost everything it hears. Note that when the
puppet is in the same room as its owner, it does not echo back the
output of commands like :. This feature prevents the puppet's owner
from getting a lot of annoying echoed messages.

Puppets and other objects that listen trigger the adescs of objects
that they enter, either via teleport, or via enter. This is because
they are considered to "look" at the object when they enter it.

* * * * *

Somewhat related to the PUPPET flag is the ROBOT flag. The ROBOT flag
cannot be set like other flags are; instead, you must use the "@robot"
command to create a robot. Something created via this command is a
cross between a player and a thing. Like a player, it may be connected
to and moved about independently. Like a thing, it owns no objects,
and belongs to the player who created it. It is "officially"
considered of type PLAYER.  Things which are set ROBOT cannot be
picked up by robots; exits which are set ROBOT cannot be gone through
by robots. This behavior is similar to KEY for puppets.

The robot flag is useful if you are running a "real" robot (an
external C or LISP construct), which needs to be a player, but still
needs to be under your control. Also, a robot can use the OUTPUTSUFFIX
and OUTPUTPREFIX commands, which many robot programs require.

When you are not connected to the robot as a player, you can use it
much like you would use a thing; for example, a robot may be set
PUPPET.  Creating a robot (via "@robot <name>=<password>") isn't
cheap, though; it will, on most MUSHes, cost you 1000 pennies. Once
created, it isn't possible to get rid of the robot without asking a
wizard to destroy it.


2.3	A Note about Privacy: @sweep

Occasionally, conversations of a private nature occur on MUDs. From
time to time, the presence of a puppet is forgotten. The @sweep command
shows everyone and everything in that room which is listening. Something
is considered to be listening if it is: a connected player, a puppet, an
object with a @listen attribute, an object with ^-listen patterns (explained
later), an AUDIBLE object or exit, or an object which has a user-defined
command on it. The latter will be explained later.

@sweep in 1.50 and 2.0 are significantly different, and so are
discussed here separately.

* * * * *

2.0 @sweep will show the following types and output:

Connected players. [player connected]
Disconnected players. [player]
Puppets belonging to connected players. [puppet(Owner name) connected]
Puppets belonging to disconnected players. [puppet(Owner name)]
Objects with a @listen or ^-pattern set. [messages]
Objects with $commands set. [commands]
Audible exits. [audible]
Audible objects, if you are in the object. [audible]
Parent objects. [parent]

This type of sweep, the default, checks both your location and
your inventory for listeners. There are also several switches for doing
more specific sweeps. Note that specific sweeps only warn you about one
form of listening - the form you are specifically sweeping for.
You may, however, combine several switches to make a @sweep of whatever
level of specificity you wish.

@sweep/commands lists only objects which have $commands set -
"[commands]" in the generic @sweep.

@sweep/listeners lists only objects which have a @listen set -
"[messages]" in the generic @sweep.

@sweep/exits checks for AUDIBLE exits in the room.

@sweep/players lists only players and puppets. It does not tell you
if a player or puppet's owner is connected, although it does tell you the
owner of a puppets.

@sweep/connected lists only connected players and puppets belonging
to connected players. It tells you who owns the puppets.

@sweep/here checks your location but not your inventory. Its reverse,
@sweep/inventory, checks your inventory but not your location.

* * * * *

1.50 @sweep will show the following types and output:

Connected players.                          [speech]. (connected)
Disconnected players.                       [speech].
Puppets belonging to connected players.     [speech].
Puppets belonging to disconnected players.  [speech].
Objects with a @listen or ^pattern set.     [speech].
Objects with $commands set.                 [commands].
Rooms with a @listen or ^pattern set.       (this room) [speech].
Rooms with $commands set.                   (this room) [commands].
AUDIBLE exits, if the room is AUDIBLE.      [broadcasting].
AUDIBLE objects, if you are in it.          (this room) [broadcasting].

1.50 "@sweep connected" will show the following types and output:

Connected players.                          is listening.
Puppets belonging to connected players.     [owner: <owner>] is listening.

Both types of 1.50 @sweep check both location and inventory.
1.50 will take the command switches "connected", "here", "inventory",
and "exits", but not in combination.

* * * * *

MudCore provides a command called +awake, which is a much more paranoid
version of @sweep; it allows you to discover not just objects which are,
in actuality, listening, but objects which might be listening. It follows
chains of message forwarding through AUDIBLE exits and @forwardlists,
as well as objects in the inventory of other objects set with @listen "*";
it thus allows you to discover just not what in the room might be
broadcasting, but where it's broadcasting to. The command displays
information in a tabular format, noting the Connected status of the
owners of the objects.

* * * * *

Puppets on MUSHes may be set DARK, but that flag has no effect on
them, just as it has no effect on a normal player. However, wizards and
wizard objects may be set DARK, and will disappear from the list of the
room's contents, although they still appear on a @sweep. As a further
caution, wizards who are set DARK also do not appear on the WHO list of
connected players. (The rationale for allowing wizards to do this is
explained in the last section of the manual).

Doing a @sweep several times throughout a private conversation is
strongly encouraged. Remember that you are not ever guaranteed privacy
on a MUD.


2.4	Attributes on Objects: Action Lists

The @asucc, @afail, and @adrop attributes are frequently used on
objects. Any command normally available to the object may be used in an
action list. Object may also re-program themselves, by enclosing the
commands which are to be deferred in curly brackets (braces), { }.

==========================
[ Example 2.4: Bubbly Pie]
> @create Bubbly Pie
Bubbly Pie created as object #1308
> @adrop pie = @adrop me={:splatters on the floor.;@destroy me};:lands on
  the floor. If it's dropped again, it'll splatter.
Set.
> drop pie
Bubbly Pie has left.
Dropped.
Bubbly Pie lands on the floor. If it's dropped again, it'll splatter.
> get pie
Bubbly Pie has left.
Taken.
> drop pie
Bubbly Pie has left.
Dropped.
Bubbly Pie splatters on the floor.
You get your 10 Mark deposit back for Bubbly Pie.
Bubbly Pie has left.
==========================


2.5  Machines: @cost, @pay, and @clone

Machines use up money as they run. Normally, the cost is 1/64 of a
Mark per command, plus the normal cost of the command. For example, if a
machine @creates something, the cost is 10 and 1/64 marks. In general, the
cost of running a machine is insignificant, but an object which is in an
infinite loop can quickly become extremely costly.

Many MUSHes have vending machines. These exist to provide some color
to the world, as well as to net the owner some money. It is generally
considered impolite to have set the cost of a vending machine to anything
far above what it costs to run the machine.

The @cost attribute is an integer, which is the amount of money a
machine must be given before it executes its "pay" programming. The @pay,
@opay, and @apay attributes are used to program vending machines.

The syntax of the commands is standard: "@<command> <object>=<whatever>"
and the attributes are triggered by the payment. The MUSH automatically
gives change to people who give a machine too much money, and rebukes those
who are too stingy, so you don't have to make sure that people are giving
your machine that correct amount of money.

Many vending machines produce objects. This is generally done by
having a copy of the object inside the machine, and then having the
machine clone the object. The syntax of that command is @clone <object>.
The object can be referred to either by name or number. @clone places the
newly created object in the room (or, in 2.0, if the /inventory switch is
given, in the object's inventory). The object is identical in all ways, save
for a different object number.

Clone-type vending machines should be set OPAQUE. This flag, when set
on something, prevents others from seeing what an object is carrying. Also,
objects given by a vending machine should be set DESTROY_OK so that people
can destroy them when they're done with them.

To @destroy an object you do not own, it must be DESTROY_OK and you
must be carrying it; if you @destroy such an object, you will receive
the message, "Destroyed.  <Owner>'s <Object>(<#dbref>)". In 2.0,
the owner will be told, "You get your 10 Mark deposit back for <Object>."
In 1.50, the owner is given that message, and gets the additional
notification, "Destroyed. <ObjectName>(<#dbref>) by <Player>."

If you don't want to see annoying "You get your 10 Mark deposit back
for <whatever>." messages every time someone destroys one of your
objects, set the object QUIET.

===================================
[ Example 2.5:  Bubbly Pie Vendor ]
> @create Hot Pie
Hot Pie created as object #8301
> @create Bubbly Pie Vendor
Bubbly Pie Vendor created as object #8302
> i
You are carrying:
Bubbly Pie Vendor(#8302)
Hot Pie(#8301)
You have 158 Marks.
> @set #8301=destroy_ok
Set.
> @succ #8301=You gobble down the hot bubbly pie.
Set.
> @asucc #8301=@destroy me
Set.
> @cost vendor=11
Set.
> @pay vendor=The bubbly pie vendor sets down a hot, steaming pie.
Set.
> @apay vendor=@clone #8301
Set.
> @tel #8301=#8302
Hot Pie has left.
> @set vendor=opaque
Set.
> drop vendor
Bubbly Pie Vendor has left.
Dropped.
> give vendor=11
You paid 11 Marks
The bubbly pie vendor sets down a hot, steaming pie.
> get hot pie
Hot Pie has left.
You gobble down the hot bubbly pie.
You get your 10 Mark deposit back for Hot Pie.
Hot Pie has left.
===================================


Database size is frequently an issue on MUSHes. One way of
preventing the dreaded "database bloat" syndrome is to avoid using
@clone whenever possible. MUSH provides for object "inheritance" via
"parenting".

An object becomes parented via "@parent <child>=<parent>", where
<child> and <parent> are of any type (and can be of different types).
A child object inherits all attributes of the parent, unless it
already has an attribute of that name, in which case the attribute on
the child "blocks" that of the parent. While no object is allowed to
have more than one parent, multiple levels of parents are allowed,
with the "ancestors" passing their traits down to the child.

In 2.0, objects also inherit any exits that their parents might have;
these show up on the "Obvious Exits" list. In neither version of MUSH
do objects inherit the locks or flags of the parent. Certain special
attributes, like @startup, are also not inherited.

Because in almost every regard, the child is identical to the parent,
cloning becomes almost unnecessary; instead of using @clone, @create
an object of the same name, set the flags and lock to be identical,
and then @parent the 'clone' to the original object, so all attributes
are 'inherited'. There is a convenient shortcut command in 2.0 which
does all of this: "@clone/parent <parent>".  This saves a large amount
of database space and also makes it very easy to maintain updates of
objects that you are making available for public consumption.

It is safe to allow someone to @chown an object after it is @parented;
the child does not inherit any special kind of control powers over the
parent. The child can, however, still inherits attributes off the
parent object, even if the owners of the child and parent are
different.


2.6  Limiting object uses:  @charges and @runout

An object may be given charges, limiting its number of uses. Each
success on the object uses one charge. To set the number of charges on an
object, use: "@charges <object>=<integer>".

When the charges on an object are exhausted, its @runout action list
is executed. The syntax is "@runout <object>=<action list>". The
action list is in the same form as the action lists used in asucc,
adrop, etc.

Any use of an action-attribute, such as @adrop, @asucc, @afail, @ause,
or @ahear, will constitute use of a charge. @trigger also uses up a
charge, although no other MUSH commands do. "@verb" triggered on
something uses up charges, if an @a-action is specified (see the
section on @verb later in the manual; basically, this command defines
@attr/@oattr/@aattr-like triplets).  Note that an object runs out when
the number of charges is equal to 0. In other words, an object with
@charges 2 can be used 3 times before it executes the @runout (the
@runout is executed immediately after the third use of the object).

============================
[ Example 2.6: Mug of Klah ]
> @create Mug of Klah
Mug of Klah created as object #135
> @asucc mug=@pemit %N=You drink some of the klah.
Set.
> @charges mug=2
Set.
> @runout mug=:is now empty.; @name me=Empty Mug; :shatters.; @destroy me
Set.
> drop mug
Mug of Klah has left.
Dropped.
> get mug
Mug of Klah has left.
Taken.
You drink some of the klah.
> drop mug
Mug of Klah has left.
Dropped.
> get mug
Mug of Klah has left.
Taken.
You drink some of the klah.
> drop mug
Mug of Klah has left.
Dropped.
> get mug
Mug of Klah has left.
Taken.
You drink some of the klah.
Mug of Klah is now empty.
Empty Mug shatters.
You get your 10 Mark deposit back for Empty Mug.
Empty Mug has left.
============================


2.7     Reacting to the Environment: @listen and @ahear

These two attributes allow machines to respond to things they hear,
including speech, poses, @emits, and whispers. The attributes are
extremely useful for programming machines that sit idle until they
hear the string "has arrived," or similar things.

The "listen" string usually contains one or more wildcard characters,
so that a single pattern of words can be listened for out of what may
be an extremely complex string. For example, an object whose "listen"
is set to "*smiles *" will match any occurrence of "smiles" followed
by a space, such as "Elisa smiles happily."

The "ahear" is the action list taken when the object's "listen" string
is matched. Ahear's general format is similar to asucc, adrop, etc.  There
are also two refinements of ahear: amhear and aahear. Amhear only responds
to strings that are generated by the object itself; ahear only responds to
strings that are not generated by the object itself. Amhear plus ahear
equals aahear, which allows the object to respond to anything it hears.

===================================
[ Example 2.7: Autogreet ]
> @listen me=* has arrived.
Elsa - Set.
> @ahear me=:waves to %N.
Elsa - Set.
[ This forces Elsa to automatically wave to something entering the room. ]
Abakin has arrived.
Elsa waves to Abakin.
===================================

Autogreets are somewhat annoying and are probably best used merely
as programming examples.

One particularly costly loop is to have an object with a @listen of
"*" and an @ahear which triggers on some particular pattern of words,
sitting in a noisy room where the @ahear is evaluated several times a
minute.  This will cause your money supply to drop rapidly, although
it is unlikely that you will notice the loop until your money is
gone. It is noted here in hopes that you will avoid making this
mistake.

MUSH allows an additional way for objects to listen. Attributes can be
scanned for ^ listen patterns (in 1.50, this only happens if no
@listen is set on an object). These pattern triggers are in the format
"^<pattern>:<action>". They function like a @listen/@ahear
combination.  Unlike @listen, messages which match the pattern do not
"go through" to the objects that the object is carrying. In order to
activate patterns on the object, though, it must be set LISTENER (in
1.50) or MONITOR (in 2.0).  Also, the object which is the origin of
the message must be able to pass the use lock of the object with the
^-pattern.

===================================
[ Example 2.8: Echo device ]
> @create Echo
Created: Object #4570.
> drop echo
Dropped.
> @va echo=^* says, "*":@emit You hear an echo... %1 %1 %1...
[ The first * matches %0, the second * matches %1. This is the "stack",
  described in more detail later. ]
Echo - Set.
> "Testing.
You say, "Testing."
You hear an echo... Testing. Testing. Testing....
===================================


2.8      Keeping your objects safe

Unless you enjoy having your stuff stolen, or are planning on giving
something away, it is usually a good idea to @lock the things you own.
"@lock <object>=me" will prevent anyone other than yourself from
picking up an object. Do note that it's usually rude to pick things
up without permission from the owner.

Locks are useful on more than just objects - they are often used on
exits. For example, you might want to lock the entrance to your
bedroom to yourself only. In general, successfully passing a lock -
going through an exit, picking up an object, etc. - will trigger the
@succ attributes. Failing to pass a lock will trigger the @fail
attributes.

The generic syntax is "@lock <object>=<key>". The object and key can
be name, number, "me" or "here". If the key is a player, you must
prefix the player name with a * - i.e. "@lock object=*Malachite".  In
general, if you want something to be locked against everything, lock
it to #0.

To unlock an object, simply use @unlock <object>.

Boolean expressions are allowed in locks, as are parentheses for
grouping.  A lock of 'obj1&obj2' means that the thing trying to pass
the lock must be BOTH obj1 and obj2. A lock of 'obj1|obj2' means that
the thing trying to pass the lock must be EITHER obj1 or obj2. Make
sure that you don't confuse these.  There is also a negation operator,
'!'.  '!obj1' means that the thing trying to pass the lock must NOT be
obj1.

Carry locks allow you to check if a player is carrying a certain
object. @lock <object>=+<key> only allows someone carrying <key> to pass the
lock. Is locks allow passage only if you are the key: @lock <object>==<key>.

The normal @lock <object>=<key> allows passage either if you carry
the key, or you are the key; thus, a carry lock plus an is lock equals a
normal lock.

Indirect locks allow you to lock an object to the key of another
object, thus creating "standard" locks. The syntax is @lock <object>=@<key>
For example, if the <key> is locked to obj1|obj2, then <object> will also
be locked to obj1|obj2.

Ownership locks allow you to lock to all objects with the same
owner. @lock <object>=+<key> only allows someone with the same owner as
<key> to pass the lock.

* * * * *

         You can lock things to attributes. For example, to make a door which
only allows females past, @lock door=sex:f*  Wild cards, greater than, and
less than signs may be used. The latter two refer to alphabetical order:
@lock door=name:<m  will set the door passable to only those people whose
names begin with a through l.
         One special variant of the attribute lock is the evaluation lock.
It evaluates an attribute, and compares it to a given value; if they are
the same, then the object passes the lock. The attribute is evaluated as
a U() function (see the discussion of user-defined functions later in
this manual for details). The syntax is @lock object=<attribute>/<value>
The person attempting to pass the lock is passed as the enactor to the
attribute U-function. Evaluation locks are an advanced programming technique;
don't worry if you don't understand them.

* * * * *

2.0 provides a wide variety of locks; in additional to the "basic" lock,
there are enter, leave, use, page, give, receive, telout, tport, and
link locks. They are set using @lock/<lock name> and @unlock/<lock name>.

An enter lock prevents someone from entering an object unless
he passes the lock. The object must also be ENTER_OK or owned by the
person trying to enter it.

Leave, give, and receive locks are obvious: they control who
is allowed to leave the object, who is allowed to give the object, and
who is allowed to give things to the object, respectively.

A use lock prevents someone from "use"ing, performing $commands,
or triggering ^-listen patterns on an object unless they pass the lock.
This provides another form of security on objects; to prevent someone from
abusing the $commands on your personal objects, all you need to do is to
@lock/use it to "me", so you are the only person who can use the object.
Please note that if you uselock yourself, you cannot be given money (since
that could potentially trigger the @apay attribute on you).

A page lock prevents someone unless they pass the lock. It does
not prevents their objects from paging you; to achieve this affect, you
need to use the ownership lock primitive ($). If you want to prevent someone
and all their objects from paging you, use "@lock/page me=!$*playername"  --
i.e., if Ambar wants to prevent Joarm and his objects from paging her, she
types "@lock/page me=!$*Joarm". The '!' signifies negation, the '$' signifies
ownership, and the '*Joarm' forces the game to parse the name as a player
name. Thus the lock reads "not objects owned by player Joarm". In 2.0, this
also prevents Joarm and his objects from @pemit'ing to Ambar; in 1.50, the
HAVEN flag is required to stop @pemits).

A link lock controls who may link to a LINK_OK location (for
linking exits or setting drop-tos for rooms) or an ABODE location (for
setting the homes of players or things).

* * * * *

Lock types in 1.50 are somewhat more limited. Enter locks and use
locks are provided. Page locks are a subset of use locks (a use lock
on a player is the page lock). Teleport locks are a subset of enter
locks (an enter lock on a room is the teleport lock). They are set
using the @lock/enter (@unlock/enter) and @lock/use (@unlock/use)
commands. Except for the fact that they set the Enter/Teleport and
Use/Page Keys instead of the regular Key field on an object, they
behave like @lock/@unlock. When you examine a room, you will be shown
the key "Teleport Key" instead of "Enter Key"; when you examine a
player, you will be shown the key "Page Key" instead of "Use Key".
1.50 will, however, recognize the /tport and /page switches, and set
the appropriate lock for you.

In 1.50, be careful, since a page lock also acts like a use lock,
on a player. If you @lock/use yourself to "me", not only will you prevent
people from using $commands on you, but you will prevent people from paging
you. You should, in general, avoid putting $commands on yourself. You
probably also want to leave yourself page-unlocked. A page lock is useful
if you don't want someone to page you but you don't want to set yourself
HAVEN (and thereby block out all pages).

			----------

Changing ownership of an object:  occasionally, you may want to give
a gift to someone, and let them own an object that you have created. The
@chown command allows you to change ownership of something.

For mortal players, to change ownership of something, the original
owner must set it CHOWN_OK. The player who is receiving the thing must then
@chown <thing>=me. If the thing is an object, the receiving player must be
able to pick it up. If the thing is a room or exit, the receiving player must
be in the same room. Wizards can simply @chown #<object>=player.

If you own an object that you want to make sure you don't lose,
set its home to yourself, using @link <object>=me, and then set the object
STICKY. Objects set STICKY will automatically go home when dropped; thus,
when the object is dropped, it will return to you.

			----------

If, somehow, you manage to lose one of your objects, the @find and
@search commands can be very useful. @find <string> will search the database
for all objects and rooms that you control whose names contain <string>.
@find without any arguments displays all objects and rooms controlled by you.
This command costs (usually) 100 pennies, since it is computationally
expensive. The exact cost can be found by "@list costs" (in 2.0) or
"@config" (in 1.50). The cost for "@find" is the standard cost for all
computationally expensive commands on a MUSH.

"@find <string>=<first dbref>,<last dbref>" will allow you to limit the
dbref range searched. This version of the command will check every object
from <first> to <last>, inclusive. If you do not specify a dbref, <first>
is assumed to be 0 and <last> is assumed to be the last object in the db

* * * * *

The @search command checks all rooms, objects, and exits owned by
you. If used without arguments, it prints all of them out. @search can be
restricted to certain classes - type (rooms, exits, objects, players),
name (search for a string, like @find), and flags. @search is generally
faster than @find.

The scope of a @search may be limited in a fashion similar to @find.
The range must be the _last_ argument to @search. For example:
"@search flags=p,100,500" would find all objects with the 'p' (PUPPET)
flag between dbrefs #100 and #500.

Note that @search and @find may be more expensive on certain MUSHes,
especially those that run on slower machines, or are disk-based. 2.0 MUSH
code is disk-based; limited @searches (restricted by a flag, for example)
may not be terribly slow, but a @find might hang the server for several
minutes (and bring the wrath of the wizards down upon you).

* * * * *

To get a count of how many objects you own, use "@stats". In 2.0,
"@stats" with no switches returns the total number of objects in the database.
"@stats/all" returns a breakdown of types in the database. "@stats/me"
returns a breakdown of what you own. 2.0 @stats breakdowns cost the same
as @find, so be careful with it.

In 1.50, "@stats" returns a breakdown of types in the database.
"@stats me" returns a breakdown of what you own. Wizards can use
"@stats <player>" to get a breakdown of what any player owns.


2.9    Do it!  --  falcon

Issue the following commands:
@create <falcon's name>
@set <name>=puppet
@desc <name>=<whatever it looks like>
@lock <name>=me
@succ <name>=You call to <name> and <he/she> lands on your arm.
@osucc <name>=calls to <name> and <he/she> lands on %p arm.
@fail <name>=You try to pick up <name> but <he/she> bites you!
@ofail <name>=tries to pick up <name> but <he/she> bites %o!
@drop <name>=You allow <name> to fly off your arm.
@odrop <name>=allows <name> to fly off %p arm.
@listen <name>=<Your name> has left.
@ahear <name>=@wait 5={:flies after <Your name>; @set me=!puppet;
   @tel owner(me); leave; @set me=puppet}
[ This last statement forces the puppet to follow you around. In order for
  this to work, however, the puppet must be set INHERIT. ]
[ Obviously, you can have your own variations on these. ]

INDEX OF SECTION I EXAMPLES:

1.2   Demonstration of basic commands
1.3a  Desc
1.3b  Succ
1.3c  Fail and Drop
1.5   Basic character set-up
2.1   Basic object commands
2.2   Puppet
2.4   Bubbly Pie
2.5   Bubbly Pie Vendor
2.6   Mug of Klah
2.7   Autogreet
2.8   Echo device
2.9   Falcon

MUSH Manual Version 2.008:
   Copyright 1993, 1994, 1995, Lydia Leong (lwl@netcom.com / Amberyl)
   Last revised 5/22/95.

Section II: Building and an introduction to programming

Table of Contents:

3. Building.
 3.1  Creating a room: @dig, FLOATING flag
 3.2  Connecting rooms: @open, @link and @unlink, LINK_OK flag, @entrances
 3.3  Refinements: ABODE and JUMP_OK flags, drop-tos and STICKY flag on rooms
 3.4  Exit conventions and the TRANSPARENT flag
 3.5  Do it!   --  home
4. Introduction to Programming
 4.1  The stack and string substitutions - % substitutions
 4.2  General attributes and action lists - @trigger and GET()
 4.3  The queue: @ps, @wait, and @halt. HALT flag
 4.4  Decision making: @switch
 4.5  Other ways of triggering: @use and @startup
 4.6  User-defined commands: $command, @scan, @verb
 4.7  Introduction to functions: ADD() and other math, RAND(), TIME()
 4.8  Do it!  --  falcon control


3. Building

3.1   Creating a room

Building a room is done quite simply, using the @dig command. The syntax
is: @dig <Room name>=<in1;in2;in3;etc>,<out1;out2;out3;etc>

in1, in2, and in3 are all exit "aliases" - typing any one of these names will
bring you through the exit into the room. You may have as many of these as
you wish; the names must be separated by semi-colons. in1 will be the visible
"primary" exit name, which appears in the room's Obvious Exits list.
out1, out2, and out3 are similar. This exit goes from the room you just dug
to the room that you are in.

On TinyMUDs, building convention dictates that exits be set DARK - i.e.
no exit names appear in the "Obvious Exits" list. Many people like visible
exits, however, and in the age of MUSHes, most exits are visible. Visible
exits are the default.

You must control the room that you are @digging from. If you don't
own a room, you should first @dig <Room name> and then @tel to that room.
(Or use @dig/teleport, which builds the room then moves you there).
You can then build off that room. If your room is not linked to something,
however, you will occasionally get the message "You own a disconnected room,
<Room name>."  To avoid this, set the room FLOATING.


=============================
[ Example 3.1: Living Room ]
> l
Foyer(#3108R)
This is the foyer of a small private home.
Obvious exits:
Doorway
> @dig Living Room=Living Room;lr;living,Foyer;f;out;o
Living Room created with room number #3813.
Opened.
Trying to link...
Linked.
Opened.
Trying to link...
Linked.
> l
Foyer(#3108R)
This is the foyer of a small private home.
Obvious exits:
Living Room  Doorway
> lr
Living Room(#3813R)
Obvious exits:
Foyer
=============================


3.2   Connecting rooms

To open an exit between two existing rooms, use the syntax
@open <in1;in2;in3;etc>=#<room>,<out1;out2;out3;etc>   This will open and
link exits between the two rooms. You can also open an exit in but not
out by simply using @open <in1;in2;in3;etc>=#room

To change an exit destination, simply "@link <exit>=#<new room>".
(Certain older versions of MUSH might require you to first "@unlink exit".)

Be careful not to leave exits unlinked, because an unlinked exit will become
the property of whomever @links it. If you want to have an exit going no place,
like something called "sit" which displays the @fail message "You sit down."
@link the exit to the room it is in - i.e. @open sit=here. @lock sit=#0.
@fail sit=You sit down.

You can let people open/link exits to one of your rooms by setting it
LINK_OK. Note that people cannot open an exit from your room into something
else; they can only link an entrance.

* * * * *

The "@entrances <object>" command returns all links to <object> --
exits which are linked to the object, rooms which have their drop-tos set
to the object, and players and things which have their homes set to the
object. This command in 1.50 also takes switches, allowing you to specify
exits, rooms, players, or things alone. This command is computationally
expensive, costing the same as @find.

You can limit the dbref range which @entrances searches by  specifying
"@entrances <object>=<first object>,<last object>". This is similar to
restricting the range on @find.


3.3   Refinements

If you want people to be able to @teleport to your room, set it
JUMP_OK. Beware - if you are in a JUMP_OK room and someone does a @whereis
on you, the room number will be listed, and that person will be able to
@tel to your location, so if you don't want unexpected visitors dropping
in, it might be best not to set the room JUMP_OK.

If you want other people to be able to set their homes in your room -
i.e. be sent there automatically when they type 'home' - set the room ABODE.
To set yourself or another object's home, @link <thing>=<here/#room>.

In older versions of MUSH code, most notably MicroMUSH, the JUMP_OK
and ABODE flags are merged; a room set ABODE may both be @linked to and
@teleported to.

* * * * *

Rooms may be @linked to other rooms, using @link <room1>=#<room2>.
This sets a "drop-to". Objects dropped in room1 will automatically be sent
to room2. "Drop-tos" may be delayed by setting the STICKY flag on room1.
If the room is STICKY, the drop-to will not be performed until the last
player has left the room.


3.4   Exit conventions

There are certain exit conventions used on TinyM*s which make following
other players around easier. Exits should, if possible, have an @osucc and
@odrop message. The @osucc message is triggered when someone uses an exit;
it is displayed to everyone else in the room that the person just left.
The @odrop message is triggered the same way, but is displayed to everyone
in the room that the person enters. Thus, you can tell where people are
going to, and where they are coming from.

For purely aesthetic purposes, exits often have @desc and @succ messages.
The @desc message is displayed when someone "looks" at an exit; the @succ
message is displayed to the person who walks through the exit.

* * * * *

Several clever things can be done with "null" exits. These are exits
that don't lead anywhere, but simply display a message to the player. For
example, an exit named "sit" could give the message "You sit down." These
exits are usually locked to #0, linked to the room they are in, and DARK.
Use of these kinds of exits is generally discouraged on MUSHes that enforce
building quotas and/or are trying to conserve disk space.

In areas that use a lot of directions - north/south/east/west etc. - it
is often helpful to have a null exit with the names of the remaining directions
in it. For example, if a room has exits in all directions except east and
west, a null exit called east;e;west;w with a @fail message of "You can't
go that way."  is very helpful. Otherwise, the player who types "east" will
simply get a "Huh?  (Type "help" for help.)" message.   Before you make such
fake exits in your rooms, though, it might be a good idea to check that your
MUSH doesn't have them already defined in the Master Room.

MudCore provides the Master Room support for these fake direction
exits (and the message "There is no exit in that direction.")  MudCore
takes this a step further, however, providing customization of these
fake exits without taking up more database space for extra "real"
exits. Sometimes, when building an area, you will want to have, for
example, a "north" exit which provides a message like, "You walk down
a long corridor, discover nothing interesting, and return to where you
started."  and doesn't actually lead to another room. Such exits give
the illusion of "space", making a small area feel larger. In MudCore,
"fake" exits in the cardinal directions can be designed by placing the
attributes DESC_<direction> and FAIL_<direction> on the room. For the
above example, one might use, "&DESC_NORTH here=To the north is a
long, featureless corridor." and "&FAIL_NORTH here=You walk down a
long, corridor, discover nothing interesting, and return to where you
started."

* * * * *

There is a flag called TRANSPARENT, which can be set on exits. If this
flag is set, players looking at the exit see, after the exit description,
the description of the next room and its contents (but not its succ/fail
messages or exits). This is useful for creating the illusion of an archway
or similar portal, where it makes logical sense to be able to look through
it into the next room.

In 1.50, the TRANSPARENT flag can also be set on rooms. This causes
the obvious exits in the room to be displayed with each exit on a line
by itself, giving the destination room. For example, you might have:

   Obvious exits:
    South leads to Foyer of the Bank.
    East leads to Intersection of Park and Hill Streets.

instead of:

   Obvious exits:
   South  East


3.5   Do it!  --  home

This builds a very simple home of three rooms, linked in a triangle:

              Living Room
                |       \
            Workroom------Bedroom

Issue the following commands:
@dig/teleport Living Room
[ The room will be dug and you will be moved into it. Note its dbref number ]
@set here=FLOATING
[ Suppresses disconnected room warnings ]
@desc here=<whatever the room looks like>
@dig Workroom=Workroom;w;work;south;s,Living Room;lr;living;north;n;out;o
go workroom
@desc here=<whatever the room looks like>
@dig Bedroom=Bedroom;b;east;e;bed,Workroom;w;work;west
go bedroom
@desc here=<whatever the room looks like>
@open Living Room;lr;living;northwest;nw;out;o=#<xxx>,Bedroom;b;bed;
 southeast;se
[ Note: the previous line is wrapped-around. <xxx> is the room number of the
  Living Room, which you should have noted earlier. ]
@set here=ABODE
@link me=here
[ Sets your home to this bedroom ]

All three rooms are dug and linked - now, all you have to do is to spiffy
up the exits, and you're all set!


4. Introduction to Programming

4.1   The Stack and string substitutions

The MUSH stores several variables, related to the cause of an action,
the object that is executing an action, and the program state during that
action, referred to as the "stack". These are accessed via a "percent
substitution".

One such variable is the "enactor" -- the object which caused an
action to be performed. For example, if Sareena looks at a Plush Shaav
Doll, Sareena is the enactor. The enactor is sometimes referred to as the
"cause". The percent substitution '%N' returns the name of the enactor; in
this case, it would be "Sareena". The substitution '%n' also returns the
name of the enactor, but the first letter is in lower-case. Another
substitution, '%#', returns the dbref number of the enactor.

It is also possible to get the appropriate pronoun for the enactor.
'%s' is the subjective pronoun (he/she/it). '%o' is the objective pronoun
(him/her/it). '%p' is the possessive pronoun (his/hers/its). The capital
letter forms ('%S', etc.) return the pronoun with the first letter
capitalized. The game determines the pronoun to use by looking the @sex
attribute on the enactor. These substitutions are equivalent to the
function evaluations "SUBJ(%#)", "OBJ(%#)", and "POSS(%#)".  In the
example above, since Sareena is female, these substitutions would return
"she", "her", and "hers", respectively.

The substitution %l returns the dbref number of the enactor's
location. This is useful when programming objects in the Master Room,
and does not pose a "security risk", since the enactor has volunteered
his position by triggering a $command or similar.

The object performing the action can be referenced via '%!'. This
returns the dbref number of the object. It is equivalent to the function
evaluation "NUM(me)". In the above example, the object that has been
triggered (and thus is performing the action) is the Plush Shaav Doll.

* * * * *

The "stack" in MUSH is simply a place where strings are stored; it
is not a literal "stack" in the usual sense of having a top object which
can be pushed and popped (as in MUF, or as defined in a standard computer
science class). The stack consists of ten strings, numbered 0 through 9.
Strings on the stack are referred to as %0, %1, %2, and so on, through %9.
The mechanisms for copying strings into the stack will be explained later.

Related to "percent" substitution is the V() function. It produces
identical output to the equivalent percent substitution. For example,
'[v(0)]' is equivalent to '%0', and '[v(N)]' is the same is '%N'.
Throughout this manual, however, '%0' and other percent substitutions
will be used instead of 'v(0)', since the evaluation of percent subtitutions
is faster than the evaluation of V-functions.

26 registers, "numbered" va-vz, are available for programming, as part
of the "standard" collection of MUSH attributes. They may be accessed by
either %va, or [v(va)]. Note that the square brackets [] force something to
be evaluated as a string.

1.50 provides the additional registers wa-wz and xa-xz. These behave
in a manner identical to va-vz.

Percent substitutions should always be used instead of functions,
where possible. In fact, you should ALWAYS use the percent substitution,
unless you are SURE that the function version is required -- use %N instead
of v(N), %! instead of num(me), and so forth. There are virtually no
situations which require the functions, and thus using the function
versions is inefficient and wasteful. Furthermore, please note that
it's just "%0", NOT "[%0]"; the additional square brackets cause an
unnecessary extra evaluation and thus are inefficient.

Please note that if you access something with a percent-substitution, if
you capitalize the first letter of the substitution, then the first letter
of the text returned will also be capitalized.

The S() function forces an additional round of pronoun substitution.
This is useful if you are evaluating a string and want to force the parser
to substitute in the values for all (non-escaped) functions.

Percents can also be used to add in special characters. %r is a carriage
return, %t is a tab character, and %b is a blank space. To show a literal
"%", use "%%".  '%r' is actually two characters (a carriage return and
newline), and functions like STRLEN() will count it as two.

Finally, there are temporary storage "registers", also numbered 0 through 9.
They are set via the function SETQ(), and retrieved via the function R(),
or through the %q-substitution. The values set via SETQ() are preserved
through the entire command list associated with a given command. SETQ()
is a function which just returns a blank string, and has the syntax,
"setq(<register number>,<value>)".  "r(<register number>)" retrieves the
value. These functions will be explained in greater detail later.
For now, just believe that they allow you to keep values around
temporarily. The odd name SETQ comes from the programming language LISP.

======================================
[ Example 4.1:  Percent demonstration ]
> @sex me=female
Set.
> @va me=test
Set.
> say %va
You say "test"
> say %Va
You say "Test"
> say %N is demonstrating %p example.
You say "Amberyl is demonstrating her example."
> say [setq(0,testing for fun)]-- %q0
You say "-- testing for fun"
> say [setq(0,testing for fun)]-- %Q0
You say "-- Testing for fun"
======================================


4.2   General attributes and action lists

The 26 registers are often referred to as "general attributes," since
they can be used to store anything. Often, they are good places to put
variables. In addition to being accessible by the v-function, they can
also be accessed by using the GET() function. The syntax for this is
"get(object/attribute)". "[get(me/va)]" is always equivalent to "[v(va)]"
or "%va".

GET() is very similar to the v-function, except it requires an object
to get the attribute from. It may be used to get any attribute - registers,
descriptions, non-standard attributes, etc. When working only with one object,
it is generally more efficient to use a v-function instead of using GET().

GET_EVAL() is similar to GET(), except that it also evaluates the
attribute. U() is also similar, and also evaluates the attribute, but
it can be used for user-defined functions which take parameters (more
on this later).

GET_EVAL()'s syntax is like GET()'s:  "get_eval(object/attribute)"
U()'s basic syntax can be like either V()'s or GET()'s; either
"u(attribute)" or "u(object/attribute)" is valid. (For information
on how to pass parameters to U(), see a later section in this manual.)

There is a subtle difference between the two functions, in addition to
U()'s ability to take parameters
The enactor of a GET_EVAL() is the object which is actually
performing the GET_EVAL(); the enactor of a U() is the original enactor.

======================================
[ Example 4.2a:  GET_EVAL() vs. U() ]
> say %!
You say "#3"
> @create Test
Test created as object #1034
> @va test=Enactor: %# -- Me: %!
Set.
> @vb test=$test: @pemit %#=Get_Eval: [get_eval(me/va)]%rU: [u(va)]
Set.
> test
Get_Eval: Enactor: #1034 -- Me: #1034
U: Enactor: #3 -- Me: #1034
======================================

If you're confused by the difference between GET(), GET_EVAL(), and U(),
don't worry about it; details will be provided later, and you don't need
to worry about the latter two functions if you're only doing very basic
things with MUSH.

* * * * *

General attributes are often used to store action lists, which are
long lists of commands, to be queued and executed. For example, you could
@create an object called Test, and "@va Test=:explodes.; @destroy me"

General attributes are usually activated by "triggers". The syntax for
this is @trigger object/attribute. @trigger is usually abbreviated to @tr.
Most of the time, one attribute will trigger another, but you can also type
directly @tr object/attribute.

For example, if you typed @tr Test/va, from the example above, you would see:
  Triggered.
  Test explodes.
  You get back your 10 Mark deposit for Test.
  Test has left.

You may also pass variables on the stack from attribute to attribute, using
trigger. Often, this is a must, since the stack is cleared when something
new is triggered. The syntax is "@tr object/attribute=thing,thing,thing,etc."
These new things become %0, %1, %2, etc., respectively, in the triggered
register. Almost anything can be legally passed on the stack - function
evaluations of any type, % arguments, numbers, strings, etc.

======================================
[ Example 4.2b:  Sentence Reverser ]
[ This object listens for four words and prints them out backwards. ]
> @create Reverser
Reverser created as object #25789
> @listen reverser=* says "* * * *"
Set.
> @ahear reverser=@tr me/va=%4,%3,%2,%1
[ Note that %0 is left out, since %0 is the * says - the person talking ]
Set.
> @va reverser="%0 %1 %2 %3
Set.
> drop reverser
Reverser has left.
Reverser has arrived.
Dropped.
> "First second third fourth
You say "First second third fourth
Reverser says "fourth third second First"
===========================================


4.3   The queue and delayed execution


The queue is the list of commands that the MUSH is going to execute.
All commands are put into it. Most are evaluated quickly, in the order
that they enter the queue (first to last), although @trigger takes at
least one queue cycle to execute and @force at least two. Setting
an attribute also takes time. One must be careful, when programming, that all
commands are getting executed at the correct times. There is no hard and fast
rule for this; experimentation is generally the only way to find out if your
object is executing commands in the correct order.

The queue may be checked by doing a @ps. If you have an infinite loop,
this is likely to be very long. If you're not sure if an object of yours is
infinite looping, @ps is a surefire way of checking.

@ps separates the queue into four sections - Player, Object,
Wait, and Semaphore. The player queue shows what you have triggered; the
object queue shows what your objects have triggered. The Wait queue shows
commands that will be executed in the future - commands that you have queued
using @wait (explained below). The Semaphore queue shows semaphore countdowns
(explained later). The total number of queued commands is also displayed.

The default @ps switch is "@ps/brief". This shows the objects
and the commands they are running. For the wait queue, it also shows
the time to wait. For the semaphores, it shows the object that the command
is waiting on, and if the semaphore is using the timer option, it also
shows the remaining time. Finally, it displays the total count of queued
commands in each of the four categories.

"@ps/long" displays all the information that "@ps/brief" does,
plus the enactor of the object, and any variables which are being passed
on the stack for eventual execution as part of a @trigger.

"@ps/summary" shows just the total count of queued commands. Note
that @ps defaults to displaying the queue for the individual executing
the @ps; only wizards may specify a player name or the "/all" switch.
In the totals line, no matter what switches are specified, the numbers
in each category are shown as Number1/Number2. The first number is the
number of queued commands that you have in that category; the second
number is the total number of commands queued in that category.
Player and Object categories also have a "[#del]", where "#" is the
number of commands deleted from the queue via @halt.

* * * * *

@ps in 1.50 is somewhat different. "@ps" with no arguments shows
your personal queue - the objects and the commands they are running,
and, for the wait queue, the time to wait. It also displays the total
count of queued commands in each of the queues, in the format
<Number of your commands> / <Total number of commands in that queue>.

"@ps all" prints the queue for all players. Wizards can also do
"@ps *<player>" to get a queue for that player. In both cases, a queue
count is provided.

Anyone may do a "@ps count" to get a count of the number of
queued commands.

* * * * *

Infinite loops on objects are dangerous. Every queued command costs
1/64th of a penny. Plus, if an object loops badly enough, it can severely slow
down the game for others. If you have a loop, you can use @halt. It clears
your personal queue. @halt <command> clears your personal queue, and adds that
new command to the queue. @halt <object>=<new command> clears that object's
queue and adds that new command to the queue.

The other way of halting something is to set the HALT flag on it. An
object set HALT is essentially inert - it does not @listen, @triggers and
@force don't work on it, etc. Also, in 1.50, UFUN() and ZFUN() will return
"#-1 OBJECT HALTED"  (recursion in a UFUN or ZFUN will automatically set
the object HALT).

The @halt command in 1.50 is slightly different. If you, or one of
your objects, does a "@halt", it wipes out your entire queue. There is no
way to clear the queue commands on just one object. You can also do
@halt <player>=<new command>, which wipes out the player's entire queue
and places the new command in it; if you are not a wizard, the player must
be yourself. "@halt <object>" in 1.50 with no new command also sets the
object HALT. If you just want to stop an infinite loop, use "@halt" with
no arguments.

There is one command called @allhalt (1.50. In 2.0, it's @halt/all)
which is wizard-only. It clears the queue for the entire MUSH, and is used
in emergencies. All connected players receive the message, "Your objects
have been globally halted by <Wizard>."

* * * * *

The syntax of @wait is simple:  @wait <number of seconds>=<command list>
There is another, more complex, type of @wait which is timed on objects;
this type of @wait involves a "semaphore" and will be described later.
@wait is very useful for trying to get objects to execute commands in the
correct order, as well as for doing time-delayed sequences - for example,
descriptions on a room that change every few hours.

=============================
[ Example 4.3:  Explosive
[ This will create an object which explodes fifteen seconds after being
  dropped. It gives a warning five seconds before it explodes. ]
> @create Explosive
Explosive created as object #23083
> @drop explosive=You set down the explosive and ignite it.
Set.
> @adrop explosive=@wait 10=:pulses dangerously. It'll explode in another five
seconds!;@wait 15={:explodes!;@destroy me}
Set.
> drop explosive
Explosive has left.
You set down the explosive and ignite it.
[ 10 seconds pass ]
Explosive pulses dangerously. It'll explode in another five seconds!
[ another 5 seconds pass ]
Explosive explodes!
You get your 10 Marks deposit back for Explosive.
Explosive has left.
============================


4.4   Decision making: @switch

@switch is the closest thing to IF-THEN-ELSE on a MUSH. It is similar to
the CASE statement in many programming languages. Its syntax is
@switch <var>=<cond1>,<action1>,<cond2>,<action2>,<cond n>,<action n>,<default>
@switch statements may be nested. One must be very careful about using commas
and semi-colons when using @switch - any statements which contain either commas
or semi-colons should be surrounded by curly braces { }. A comma will signal
a new case/action, and a semi-colon the end of the @switch statement, if not
in the curly braces. This is a commonly made mistake - when programming
objects whose @switches do not appear to work, always check for misplaced
commas or semi-colons.

One thing to note is that the variable to switch on does not have to be
evaluated within square brackets [ ]. Percent substitutions, like %va, are
okay to switch on, as are functions simply stated, like words(v(va)).

After the variable name is ALWAYS an equals sign. @switch %va=>1,:foo
does NOT mean "if va is greater than or equal to one, :foo". It means "if va
is strictly greater than one, :foo". The equals sign is simply part of the
@switch syntax. If you want greater than or equal to, you will have to use
the GTE() function.

There are two option switches to @switch, /first and /all. In 2.0, which
one is the default will depend on the MUSH ("@list options" to see).

"@switch/all" performs the actions associated with all matching
targets. In other words, if the targets are not mutually exclusive, more
than one set of actions may be undertaken. Its 1.50 equivalent is the
standard "@switch" command.

"@switch/first" matches the first target it can, and executes the
statements associated with that. Even if the targets are not mutually
exclusive, only the actions associated with the first target matched will
be executed. The 1.50 equivalent of this is the "@select" command.

=============================
[ Example 4.4:  Dog ]
[ The dog will respond to simple commands that someone says ]
> @create Dog
Dog created as object #23084
> @listen dog=*"Dog, *"
Set.
> @ahear dog=@switch %1=sit,:sits down.,roll over,:rolls over obediently,play
  dead,:flops onto the ground.
Set.
> drop dog
Dog has left.
Dog has arrived.
Dropped.
> "Dog, sit
You say "Dog, sit"
Dog sits down.
> "Dog, play dead"
You say "Dog, play dead"
Dog flops onto the ground.
> "Dog, roll over
You say "Dog, roll over"
Dog rolls over obediently.
=============================


4.5   Other ways of triggering

It is frequently useful to be able to trigger an object without having
to pick it up, drop it, or have it listen for something. Therefore, MUSH
provides for "using" objects.

The attributes @use, @ouse, and @ause are associated with the "use"
command. "use <object>" triggers these three registers (note the absence of
the @ sign in triggering). An object can only be used if there is something in
the @ause register. The person who uses the object is shown the message in the
@use; the other people in the room see the @ouse message. The @ause command
list is executed. This, in essence, works just like "get" and "drop" - the
command "use" has simply been added.

========================================
[ Example 4.4:  Bubbly pie revisited ]
[ @using the bubbly pie performs an "eating action" and destroy. ]
> @create Bubbly pie
Bubbly pie created as object #30216
> @ause pie=@emit %N gobbles down the bubbly pie.;@destroy me
Set.
> use pie
You use Bubbly pie
Elsa gobbles down the bubbly pie.
You get your 10 Marks deposit back for Bubbly pie.
Bubbly pie has left.
========================================


Another way to trigger an object is to set its @startup. The commands
in the @startup attribute are executed whenever the MUSH is restarted.
This is useful for objects that need to run continuously, such as clocks.
Objects with a @startup attribute are automatically given the STARTUP flag,
represented by "z". This flag is simply used for internal accounting and
does not affect anything else.


4.6   User-defined commands

Perhaps one of the most common ways of triggering an object, user-defined
commands are the closest things to MUCK @action that MUSH provides. They allow
other players to type "command <arguments, if any>" and have that execute just
as if the command was part of the MUSH. Unlike MUCK, however, there are few
global user-defined commands. One must be in the same room with, or carrying,
the object on which the command is defined. The only exceptions to this are
exits/commands defined on the "master room". See the wizard section of this
manual for details.

These commands may be set on any register or non-standard attribute.
The syntax is:  @<attribute> <object>=$<command>: <action list>
The command may take arguments by using * or ?, etc., in a format similar to
that use by @ahear/@listen.

User-defined commands are matched on every object in the room or in
your inventory, so you may want to avoid command names that might be
extremely common. Commands on the MUSH are parsed in the order: exit
names, defined MUSH commands (like @desc, page, etc.), then
user-defined commands, then Master Room commands. You should be
extremely careful not to define commands on an object like $p
*:<action>, since this will be parsed as "page" and it will be ignored
by the object. Furthermore, note that many MUSHes have global commands
which begin with '+' and mailers which use '-' as an editing
indicator; thus, you should avoid starting your own commands with
either of those characters.

In 2.0, there are config options which determine two things:
The first is the ability of an object to trigger its own $commands. The
second is the ability to trigger $commands on players. One can, however,
always trigger $commands on an object one is carrying or is in the same room.


===============================
[ Example 4.6:  Tray of Food ]
[ This object is a tray of food which you can "eat", "drink" and "discard" ]
> @create Tray of Food
Tray of Food created as object #482
> @va food=$eat: @emit %N takes a slice of bread off the try and eats it.
Set.
> @vb food=$drink: @emit %N takes a cup of water off the tray and drinks it.
Set.
> @vc food=$discard: @emit %N discards %p tray of food;@destroy me
Set.
> eat
Elsa takes a slice of bread off the tray and eats it.
> drink
Elsa takes a cup of water off the tray and drinks it.
> discard
Elsa discards her tray of food.
You get your 10 Marks deposit back for Tray of Food.
Tray of Food has left.
==============================


Sometimes it's useful to be able to find out what $commands are
triggered in a room. 1.50's @scan command allows you to check for a
command match on objects that you control or that are set VISUAL.
The syntax of this command is simply "@scan <string>". It checks for
all possible matches on your location, its contents, yourself, your
inventory, the zone or parent room of your location, your personal
zone, and the master room. It will display the name of any objects
which have commands which could match that string, followed by the
number of commands matched in brackets.

MudCore provides for similar functionality, via its '+scan' command.
It checks for matches, starting from a specific object, and lists
the attributes and command wildcard patterns which match (if you
can examine the object), or the object which matches the commands
(if you can't examine it).

* * * * *

One interesting and quite flexible command is "@verb". This command
essentially allows you to define your own @attr/@oattr/@aattr triplets,
allowing you to define your own "standard" verbs. This command is most
useful for someone who is a wizard.

This command is in the format:
@verb <obj to read attributes off (victim)>=<obj to be told messages (actor)>,
   <attr name>, <default message for attr>,
   <oattr name>, <default message for oattr>,
   <aattr name>, <args>

Most of those those fields should be self-explanatory; <args> are
the values to be passed on the stack, as %0-%9.  For example, to simulate
"drop" with a command like "put", you would use a user-defined command
something like:

$put *: @verb [v(0)]=[v(N)],DROP,Dropped.,ODROP,dropped [v(0)].,ADROP

Under 2.0, both the victim and actor must be controlled. Under
1.50, either both victim and actor must be controlled, or the thing which
triggered the verb must be <actor> AND the object which issued the @verb
command must be able to read the attributes from <victim>.  Essentially,
though, one needs to be a wizard in order to make this command generally
useful. It is, however, a rather nifty thing to play with.


4.7   An introduction to functions

Functions are generally used to manipulate strings and other input, or
to generate or retrieve something. They are called using:
<function-name>(<arg1>,<arg2>,<etc>)  and evaluation often requires square
brackets [ ] to be put around the function. It is imperative that the right
number of arguments be passed to the function, and that the parentheses are
correctly matched. You should always use %-substitutions instead of functions
where possible, i.e., %va instead of v(va). Functions may be nested. Only
one pair of square brackets is required around a given function call.
Certain functions, such as V() and GET(), have already been introduced.

Only a few functions require no arguments; TIME(), which simply
returns the current time on the MUSH, is probably the most commonly
used of these. All other functions require one or more arguments. The most
commonly used, aside from the v, s, and get() functions, is the RAND()
function. This generates a random integer between 0 and <number - 1>.
There _is_ a limit to the number of arguments a function can take; you
can find out what this is by asking a local wizard. This is generally 100.
The limit is something to keep in mind if you are doing extremely large calls
to a function like SWITCH(), which takes an arbitrary number of arguments.

Functions used to access basic db info include NUM(), FLAGS(), OWNER(),
LOC(), and MONEY(). These are publicly accessible, and give an object's
database reference number, flags, owner, location (for a player), and money
(also for a player). These functions will be discussed in more detail
later. Other publicly accessible attributes include DESC, and
are gotten using the GET() function. All attributes on an object set VISUAL
are publicly accessible.

Functions used to process lists will be covered later in this manual.
The following functions are used for arithmetic: ADD(), SUB(), MUL(), DIV().
Note that SUB() does not exist in many versions of MUSH code; instead, one
must add the negative of the second number. Some of these functions, such
as SUB(), take ONLY two arguments. Others, like ADD(), can take multiple
arguments (just like LISP arithmetic operators). For example,
"add(2,3,4)" is equivalent to (and more efficient than) "add(2,add(3,4))".

=============================
[ Example 4.7a:  Abacus ]
[ An object that performs arithmetic ]
> @create Abacus
Abacus created as object #19831
> @va abacus=$*+*: @emit The sum of %0 and %1 is [add(%0,%1)].
Set.
> @vb abacus=$*-*: @emit The difference of %0 and %1 is [sub(%0,%1)].
Set.
> @vc abacus=$*x*: @emit The product of %0 and %1 is [mul(%0,%1)].
Set.
> @vd abacus=$*/*: @emit The quotient of %0 and %1 is [div(%0,%1)].
Set.
> 1+2
The sum of 1 and 2 is 3.
> 2x6
The product of 2 and 6 is 12.
> 8-5
The difference of 8 and 5 is 3.
> 9/3
The quotient of 9 and 3 is 3.
==============================

Here's another example, demonstrating the combined use of @switch and RAND(),
"use", and various %-substitutions.

======================================
[ Example 4.7b:  Plush Shaav Doll ]
[ To conserve space, 'Set.' messages after attribute sets have been omitted. ]

> @create Life-size Plush Shaav Doll
Life-size Plush Shaav Doll created as object #3895
> @desc doll=This is a plush doll nearly six feet in height. It's fuzzy and
  and cute, featuring the Grand Hierarch Shaav wearing his usual calm
  expression, although the effect is somewhat spoiled by the fluffy stuffing
  and bright green-button eyes. The life-sized doll is clothed in the black
  robes of the Grolims, and would probably seem to radiate evil if it didn't
  look so snuggly. It's probably made by the same people who made Belzoinks.
> @succ doll=You prop up a life-sized plush doll of Shaav.
> @osucc doll=grins evilly as %s props up a life-sized plush doll of Shaav.
> @drop doll=You drop a life-sized plush doll of Shaav on its head.
> @odrop doll=drops a life-sized plush doll of Shaav on its head.
> @use doll=You pull a string on the doll's neck.
> @ouse doll=pulls on a string on the plush Shaav doll's neck.
> @ause doll=@switch rand(4)=
    0, {:points a finger at %N and squeaks. "Die!"},
    1, {:screams:%tDeath!%tDestruction!%tChaos!},
    2, {:looks at %N for a moment, then booms to %o, "DOOM."},
    3, {:squeaks. "Mama!%b%bMama!%b%bMama!"}

[ If Polgara (a female) types "use doll", she sees "You pull a string on the
  doll's neck", plus one of the following messages: ]

Life-size Plush Shaav Doll points a finger at Polgara and squeaks. "Die!"
Life-size Plush Shaav Doll screams:	Death!	Destruction!	Chaos!
Life-size Plush Shaav Doll looks at Polgara for a moment, then booms to
  her, "DOOM."
Life-size Plush Shaav Doll squeaks. "Mama!  Mama!  Mama!"

Note the use of "%b" and "%t" substitutions for blank spaces and
tabs. Because "%t" inserts a literal tab character, the spacing will
vary depending on where tab stops are set by the player's terminal.
Also note that the @switch action clauses had to be enclosed in braces,
since the statements used inside contained commas.

==============================


4.8   Do it! -- falcon control

This section assumes that you have created the falcon as per section
2.9 of this manual. The object you will create in this example will be used
to control it. <#FL> below refers to the dbref number of your falcon,
and <FL> refers to the name of your falcon.

The controller will give you the ability to force your falcon
remotely to pose and think messages, return to you on command, and go to a
player on command, using: '<message>  to think a message, .<pose> to pose
something, return to recall the falcon, and goto <player> to go to a
player's location.

Issue the following commands:

@create <FL>'s controller
[ Then lock it, desc it, etc. ]

@va controller=$'*: @fo <#FL>=:chirps << %0 >>
[ This is used for "speech" ]

@vb controller=$.*: @fo <#FL>=:%0
[ This is used for forcing the falcon to pose ]

@vc controller=$fly *: @fo <#FL>={:soars into the air and flies off.; %0}
[ This is used to have the falcon fly in a given direction ]

@vd controller=$return: @fo <#FL>={:returns to %N.; @set me=!puppet;
    @tel me=owner(me); leave; :soars towards you!; @set me=puppet}
[ This brings the falcon back to you, with appropriate messages. The
  INHERIT flag must be set in order for this to work. ]

@ve controller=$goto *: @fo <#FL>={@switch loc(*%0)=#-1,{p <your name>=I can't
    find %0}, {:goes to find %0.; @tel me=loc(*%0); :soars towards you!}}
[ This is used to go to the location of a player. It first checks to see if
  the player can be found - if the player does not exist or the player is set
  UNFINDABLE, #-1 is returned and the falcon pages the player with the
  fail message - and then, if the player exists, teleports to that player's
  location, with appropriate messages. ]


INDEX OF SECTION II EXAMPLES:

3.1   Living Room
3.5   Home
4.1   Percent demonstration
4.2a  GET_EVAL() vs. U()
4.2b  Sentence Reverser
4.3   Explosive
4.4   Dog
4.5   Bubbly pie revisited
4.6   Tray of food
4.7a  Abacus
4.7b  Plush Shaav Doll
4.8   Falcon control

MUSH Manual Version 2.008:
   Copyright 1993, 1994, 1995, Lydia Leong (lwl@netcom.com / Amberyl)
   Last revised 5/22/95.

Section IV: Wizard's supplement

8. Owning and seeing everything
  8.1  Special privileges, ROYALTY, and Powers
  8.2  Attribute ownership - @atrchown and @atrlock
  8.3  Object ownership - @chown and @chownall
  8.4  The queue - @ps and @allhalt
  8.5  The database - @entrances, @find, @search, and @stats
  8.6  A note about security and privacy
  8.7  The Master Room and command processing
9. Wiz-specific commands
  9.1  Talking to other wizards: @wizwall and @wizemit
  9.2  Messages: @wall, @listmotd, @motd, and @wizmotd
  9.3  Locking out players: @login and @rejectmotd
  9.4  Dealing with players: @newpassword, @pcreate, @boot, @toad, and @destroy
  9.5  Dumping the database: @dump and @shutdown
10. Database control
  10.1 Quota system: limited object creation - @allquota, @quota, and @squota
  10.2 Money control: give and @poor
  10.3 Consistency checking: @dbck and @purge, @dump/paranoid, @cut, @fixdb
11. Zones
  11.1 Object zones
  11.2 Parent room zones
  11.3 ZoneMaster players
  11.4 Some notes on local wizard control
12. The Fundamental Laws of Wizarding
  12.1 Wizard Etiquette
  12.2 The Five-Step Method of player management
        warning - nasty warning - gag - boot - newpassword
  12.3 Wizard commands and when they ought to be used


This section was written with the 1.50 wizard in mind. If something is
mentioned that doesn't exist in 2.0, and you're only interested in 2.0,
ignore it.  If you're going to play with the 2.0 wizard commands that
aren't covered in this section, you probably know what you're doing and
therefore don't really need those commands covered in this manual anyway.
All wizards, however, will probably find something useful in section 12,
which provides general rules for wizarding. Mortals may find it interesting
reading.


8.  Owning and seeing everything

8.1     Special Privileges, ROYALTY, and Powers


A wizard, by definition, owns and controls everything except for God.
A wizard may manipulate any object by using its dbref number, or by using
*player. Remote get, look, and examine work, and a wizard may bypass the HAVEN
flag by using "w *<player>=<message>" to whisper a message.

A wizard may look at anything by looking at the dbref number, or by
looking at *player. Warning: in 2.0 this triggers the odesc and adesc messages.
The format of "look" for wizards is somewhat different: the object's name
and dbref number is displayed on the line above the description. When looking
at exits, the full exit name - including aliases - is displayed.

Wizards can teleport to anywhere. In 1.50, the NO_TEL flag and
teleport locks do not have any effect at all on wizards; in 2.0, however,
wizards ARE affected by teleport locks. In 2.2, this is configurable.

The UNFINDABLE flag does not prevent wizards from locating a player.
A wizard can also obtain a player's location by using loc(*player), and get
any attribute. There is _nothing_ in the database that a wizard cannot see,
except for things like the password attribute and other "internal"
dark-to-all attributes.

The LWHO() function allows wizards to obtain a list of dbrefs
of connected players. Also, in 1.50, wizards may watch connects and
disconnects by setting the MONITOR flag on themselves, or grant the
ability to do the same to another player. (NOTE: the 1.50 MONITOR flag
is NOT like 2.0 MONITOR; the equivalent of 2.0 MONITOR is 1.50 LISTENER.
2.0 has no equivalent of 1.50 MONITOR). In both 1.50 and 2.0, WHO for
wizards shows an extended listing with connect sites and other special
information; to see the listing that mortals get, use the command DOING
instead.

* * * * *

Pern version 1.14 introduced a ROYALTY flag (which can optionally be
turned off at compile-time). This flag is settable by wizards. Objects
ROYALTY can examine and teleport like wizards, but have no other wizard
powers; all of the statements about wizards above also apply to ROYALTY.
This flag does not exist in 2.0.

PennMUSH 1.50 patchlevel 7 introduced a powers system. This
enables wizards to grant specific objects, including players, the power
to accomplish certain tasks that previous were restricted to wizards.
Also, since the BUILDER and IMMORTAL flags from previous patchlevels
are, intuitively, powers rather than real flag toggles, they were changed
to powers in patchlevel 7.

The powers include "teleport anywhere", "teleport anything", "examine
anything", "boot", and most of the other useful wizard powers, save
the ability to @force/control anything. Players who receive such
powers should exercise them with the same caution a wizard should use,
and they should not be given out lightly. A player granted all the
powers has all the abilities of a ROYALTY, and more, except for the
@rwall command.  Therefore, prudence should be exercised in granting
special powers.


8.2     Attribute ownership - @atrchown and @atrlock

Attributes may be owned independently of objects. An unlocked
attribute can be changed by the owner of the object. A locked attribute
may only be changed by the owner of that attribute. Locked and unlocked
attributes are, for the purpose of triggers and similar evaluation,
exactly the same.

Only wizards may set attributes on things that they do not own. The
most recent player to change an attribute is its owner. Please note that it
does not do any harm for someone else to own one of your attributes. If the
attribute is locked, however, you will not be able to remove it _even if you
are a wizard. A wizard may, however, unlock the attribute and then remove it.

In 1.50, two commands are used to handle attributes. @atrchown
changes the ownership. The syntax is @atrchown <object>/<attribute>=<new owner>
@atrlock governs attribute locks: @atrlock <object>/<attribute>=<on or off>
@atrlock <object>/<attribute> by itself returns the status of the lock.
The 2.0 syntax (which also works in 1.50) is "@lock <object>/<attribute>",
"@unlock <object>/<attribute>", and "@chown <object>/<attribute>=<player>".
A normal "examine" shows the owner and lock status of attributes.


8.3     Object ownership - @chown and @chownall

The @chown command is somewhat different for wizards. A wizard may
@chown any object he is carrying, or any object by dbref number. The syntax
is @chown <object>=<player>. Not that *<player> is _not_ used in @chown.

@chownall transfers the ownership of everything a player owns to
another player. @chownall <player> transfers ownership to the wizard who
executes this command. @chownall <player>=*<new owner> transfers ownership
to another player. Note the use of the pointer. A @chownall should NEVER be
done without the consent of both parties involved, since it is usually
difficult to reverse, especially if the recipient owns a lot of objects
himself.


8.4     The queue - @ps and @allhalt

Wizards can use @ps all to see the contents of the entire queue, or
@ps *<player> to see the queue for one specific player.

When the queue is very full, or a machine is looping so badly or
triggering so many objects that simply halting it is not feasible, the
command @allhalt can be executed. This clears out the entire queue - player,
object, and wait, and displays to all connected players the message, "Your
objects have been globally halted by <Wizard>."  @allhalt should be used
sparingly; if the server is slow, the queue may be full, but it may not
necessitate an @allhalt. In 2.0, this is "@halt/all" rather than "@allhalt".


8.5      The database - @entrances, @find, @search, and @stats

@entrances will work on "here" or on any room number, for a wizard.
@stats can be broken down by player, using "@stats <player>"  Note the
absence of a pointer.

Wizards need to be careful with @find, since @find with no arguments
outputs the list of all objects that the wizard controls - i.e., the entire
database. @search with no arguments, however, only does a @search on the
wizard, printing out all the objects he owns. @search with any arguments,
however, looks through the entire database, not just the wizard's objects.
If you are looking for something, always try to do a @search instead of a
@find, especially if you are on a 2.0 MUSH. @search which is restricted
to a player is _considerably_ faster than @find.


8.6      A note about security and privacy. DARK.

Wizards have enormous power. No notes on a MUSH are private; a
wizard can examine them. Wizards can set themselves DARK, disappearing from
the WHO list. In 1.50, any actions taken by a dark wizard show up as
"Someone" rather than the wizard's name, if the game is so configured.
Wizards cannot listen to whispers or pages, and always show up on a @sweep,
whether or not they are dark. A wizard owns everything; he can change,
destroy, or force it to do whatever he wants (unless it is God).

Because of this, wizards must be VERY careful to make sure that
there are no programming loopholes in their objects which would enable the
objects to @force them to perform certain actions.

Wizards should also be careful to announce their presence, if they
are entering a room and are DARK. There is virtually no justification for
spying on a private conversation (the exception may be listening to two
players plotting how to crash the mud, or something similar).

A wizard should _always_ check the location of a player before he
teleports to that player. Being paged by a player does NOT mean that the
player presently wishes for company. In general, the wizard should also ask
permission to enter the room. A wizard should also never teleport a player
anywhere without asking permission first - this is extremely rude.
Occasionally, one tends to act before thinking, but a wizard should try to
act with courtesy.

Also, remember that in 2.0, wizards who exceed the idle time normally
granted to mortals before an inactivity-timeout boot are set DARK.
Wizards are also booted for inactivity, but can set their @timeout
attribute to an arbitrarily high value; they will not be booted until
that @timeout has expired. Wizards who are DARK from inactivity have a
"d" next to their time instead of a "D", in the WHO list.

In 1.50, wizards are never booted for inactivity. They are, however,
set DARK at the mortal inactivity limit, if they are already set UNFINDABLE.

If you are the sort of person who tends to forget that he is set DARK,
you might want an automatic reminder given to you when you move. The
following is useful for this:

@move me=[switch(hasflag(%!,Dark),1,WARNING: You are set DARK.)]


8.7      The Master Room and Command Processing

In both 1.50 and 2.0, the command parser goes through the steps
shown here looking for a match on the command.  If it finds one at a
particular step, it stops and performs it.  If more than one match
(say, multiple south exits from a room), one is picked at random.
$-commands are an exception to this rule, in that ALL $-commands that match
are executed, except that the master room is only checked for $-commands
if none are matched in the check around the player.

The 2.0 evaluation order:

- Uppercase commands (WHO, QUIT, etc) if typed at a terminal.
- Prefix-character commands (", :, ;, etc)
- The 'home' command.
- Exits in the current room.
- Exits in the master room
- Internal commands.
- $-commands in the following places, all checked in parallel:
   - Objects in your inventory.
   - Objects in your current location.
   - Your location (the room itself)
   - You (optionally)
- $-commands in the ZONE chain of the player's location
- $-commands in the ZONE chain of the player himself
- $-commands in the following places, all checked in parallel:
   - Objects in the master room.
   - The master room itself.

The 1.50 evaluation order:

- Uppercase commands (WHO, QUIT, etc) if typed at a terminal.
- The 'home' command.
- Prefix-character commands (", :, ;, etc)
- Exits in the current room.
- Internal commands.
- Enter aliases on objects in the current room.
- Leave aliases on the object you are in, if applicable.
- $-commands in the following places, all checked in parallel:
   - Objects in your current location.
   - Your location (the room itself)
   - Objects in your inventory.
- If nothing has been matched:
   - If the zone of the player's location is a parent room,
- Parent room exits
        - All $-commands on objects in the parent room
   - Else,
        - All $-commands on the zone object of the player's location
- If still nothing has been matched:
   - All $-commands on the player's personal zone
- As a last resort, when matching still fails,
   - Global exits (Master Room exits)
   - All global $-commands ($-commands on objects in the Master Room)

In both 1.50 and 2.0, the Master Room contains exits and commands
which are global to the entire MUSH. This should be used with caution,
as having a lot of global commands slow down the MUSH. Make sure
something is really necessary before adding it to the Master Room. If
it's only useful in some specific area of building, consider using a
Zone instead (see the later section of this manual).

Also, because it is necessary to check every attribute on every object
in the Master Room for commands which don't match anything, the number
of attributes on objects in the Master Room should be kept to an
absolute minimum.  It is also a good idea to keep the number of
objects in the Master Room down, since every object represents an
additional UseLock which must be checked.  As a general rule of thumb,
if an attribute doesn't contain a $command, it shouldn't be on a
Master Room object. For convenience, some data attributes can be kept
on Master Room objects, but this should be avoided whenever possible,
even if the data attributes are set No_Command.

Note that the parents of objects in the Master Room, and, in 2.2,
parents of objects which are contained by a ZONE chain, are not
checked for $commands. This allows you to place data attributes on
the parent, for easy reference, thus leaving you with little excuse
for ever having non-essential attributes on the object itself.


9.  Wiz-specific commands

9.1      Talking with other wizards

MUSH code provides the commands @wizwall, @wizpose, and @wizemit.
(In 2.0, these are @wall/wiz, @wall/wiz/pose, and @wall/wiz/emit). Note
that none of these use an = sign. @wizwall and @wizpose are really the same
command;  "@wizwall :<pose>" is equivalent to "@wizpose <pose>"  In the
case of @wizwall <message>, it is  "Broadcast: <Wizard> says, "<message>""
In the case of @wizwall :<pose> or @wizpose <pose>, the format is,
"Broadcast: <Wizard> <pose>". @wizemit <message> shows the other wizards
"Broadcast [<Wizard>]: <message>"

1.50 provides @rwall, @rwallpose, and @rwallemit. They work
identically to the @wiz variants, except they send messages to both
royalty and wizards, prefixed with "Admin:" instead of "Broadcast:".

Only connected players may hear these messages.


9.2      Public messages

Wizards can shout using @wall <message>. There is no way of blocking
out shouts; therefore, this should be used sparingly. It sends the
message to every connected player.

Wizards can set the Message of the Day using @motd <message>. The
message stays up until another wizard resets it, or the MUSH goes down. The
MOTD is shown to players when they connect, and when they use @listmotd.
Wizards also have a @wizmotd, which is shown to all connecting wizards.
For wizards, @listmotd displays all MOTD messages.

2.0 refers to these commands as @motd, @motd/wizard, and @motd/list.


9.3      Locking out players

In certain situations, there may be a need to disable all non-wizard
logins. 1.50 code provides the @login <on or off> command. When @login is
off, all player connections will be refused - after the welcome screen, the
message set by using @rejectmotd <message> is displayed and the player is
disconnected.

In 2.0, the command to use is "@enable logins" or "@disable logins".
The @enable and @disable commands may be used to tweak other things as
well; this is probably the most commonly used of the options. The message
displayed to players who cannot connect may be set using @motd/down.


9.4      Dealing with players

There is no easy way to retrieve the lost password of a player.
Therefore, it is simpler to simply use @newpassword <player>=<new password>.
The player is informed that the wizard has changed his password. The player
should then log in and change his password to something else that the wizard
doesn't know. Never @newpassword a player without his knowledge, unless
it's an emergency.

@pcreate is a command which only works if the MUSH is compiled under
registration. @preate <player>=<password>  creates a player with the name and
password. You may not create two players with the same name.

* * * * *

@boot *<player> can be used to force a player to disconnect from the
MUSH. This is the general punishment for being obnoxious, or for idling for
too long. If you are @booting someone for idling, you should, in general,
page them with a warning five minutes before doing the @boot.

@boot has another use -- killing off sessions of players who
are unable to disconnect, due to network problems. Generally, in this
case it is best to use "@boot/port", which allows you to boot a specific
question. In 1.50, the wizard WHO shows descriptor numbers; in 2.0, you
must use the SESSION command to get the descriptor number of a connection.
"@boot/port <descriptor number>" then closes that specific connection.
Players will often request to have "frozen", dead, connections @booted.

In 1.50, players will be booted with a message notifying them that
they have been booted off the game. In 2.0, players will also be told who
booted them off, unless "@boot/quiet" is used, in which case the player
will simply be abruptly disconnected without any kind of notification.

* * * * *

@toad turns a player into an ordinary object, called "A wart toad
named <player>" (1.50), or "A slimy toad named <player>" (2.0) and @chowns
all his objects to the wizard doing the @toad. The player will be booted off
the game, prior to being turned into an object.

@toad is actually somewhat redundant. @dest *player will @boot the
player, @chown all his objects to the executing wizard, and @destroy the
player itself. If possible, use this instead of @toad (TIM code and MUSE,
however, may be somewhat different.)

Be careful with @destroy #<dbref>. There is no check to see who the
object belongs to or what it is - be _very_ certain that you have the right
object number, or you may end up irretrievably blowing up an object which
represents hours of programming. There is no way to retrieve @destroyed
objects other than rooms (which may be set !GOING). 1.50 prevents this
somewhat by forcing wizards to use @nuke to destroy objects which do not
belong to them; please don't use @nuke as your standard command for
destruction, or you'll defeat the purpose of this safeguard!

The wizard command "slay" is a "kill" which always works. There's
generally no reason to use it, unless programming a puzzle or something
similar; all it does is give the player some money and send him home.


9.5      Dumping the database

The command @dump writes the database to disk. In 1.50, this can
take anywhere from a minute or two to half an hour - make sure not to do
overlapping @dumps. Overlapping dumps can cause crashes, incomplete database
writes, and other assorted undesired effects.

In 2.0, you don't generally need to worry about doing dumps, as the
disk database is saved fairly often and loss from crashes tends to be
minimal.

The command "@shutdown" shuts down the MUSH. It first does a @dump,
gives all connected players the name of the wizard who did the
@shutdown, and the message "Going down - Bye", then drops all
connections. Don't do this without a very good reason.

Note: if you have database damage and are shutting down because the
game will crash or doing something else equally nasty in a few
moments, DON'T! The straight @shutdown will save the database and your
damage will be permanent. In such a dire situation, you have two options:
find the God (or other person with direct access to the MUSH account) and
have him "kill -9" the process, or do a "@shutdown/abort". This will cause
the MUSH to dump core and die, allowing for the damage to be assessed later
by someone skliled with a debugger.


10.      Database control

10.1     Quotas - limited object creation

If quotas are turned on, the command @allquota <limit> displays the
current quotas and objects owned by all players, and then resets their quotas
to the new limit minus the number of objects they currently own.

@quota <player> reports the number of objects a player owns, and
his quota still available. @squota <player>=<limit> reports the number of
objects the player owns and his remaining quota, and then sets his quota to
<limit> minus the current number of objects he owns. If the limit is 0, then
@squota works identically to @quota.


10.2     Money control

Wizards have unlimited money, and can freely give out money to
players using give *player=<money>. Wizards can also take away money from
players by giving them negative money. It is generally not a good idea to
give players vast amounts of money. The command @poor <money> resets the
money of every player on the MUSH to <money>. This command should be used
sparingly, if at all.


10.3     Consistency checking

The commands @purge and @dbck will probably not be used by most
wizards. They check the database for corruption: @purge checks the destroyed
object list and makes sure that all the objects on that list are really
there; @dbck forces the database to run an internal cleanup and consistency
check every ten minutes. @dbck automatically executes @purge.

In 1.50, if, for some reason, your database is corrupted but the
game is still up (usually through a bug in the internal compression routines),
you will find that an attempt to dump the database will cause a segmentation
fault and core dump (i.e. a nasty crash).  You can generally get a clean
database write by using the "@dump/paranoid" command, which very thoroughly
scans the database before writing it to disk, checking for non-printable
characters and the like. Someone with access to the game's account should
then log in, back up the paranoid dump, and then kill off the game process
in some manner.

2.0 provides the ability to do some database repair within the
game. The first of the db repair commands is "@cut"; this cuts off the
object or exit chain at the wizard's location by setting the "next" field
of the object to NOTHING. The objects or exits beyond the cut retain
their location, but are not accessible except via dbref number.
They can be pasted back into their proper places via the @fixdb command.
This command allows you to more or less arbitrarily set the fields of
an object -- the contents, exits, location, and next pointers, as well
as the owner, value, and name. These commands are NOT to be used unless
you are CERTAIN you know what you are doing, as it is possible (and indeed
rather easy) to produce database inconsistencies/loops which can hang
or crash the server.


11.      Zones

This section only applies to PennMUSH 1.50.  Please see a later section
of this manual for a description of Zones in TinyMUSH 2.2.


11.1     Object zones

A Zone Object (or, alternatively, ZMO - Zone Master Object) is
simply an object that other objects have their zones set to. Objects
that have their zone field set to a ZMO are referred to as being in that
ZMO's zone. There's nothing at all special about a zone object, aside from
that property.

Anyone who passes the enter lock of a ZMO has control over objects
in that zone. Someone who has control of an object via passing the enter
lock on the ZMO can do many things that the object's real owner can do,
including examining the object, changing its attributes, and setting flags
on it. Two notable exceptions are the @chown and @destroy commands, which
are reserved to the object's real owner. Also, players NEVER control other
players.

This control property of zones makes it possible for two or more
people to work on a project together. A wizard is needed to @chzone a player
to a zone; henceforth, everything that player builds is automatically part
of that zone. The wizard-only @chzoneall command changes the zone of
everything a player owns. Wizards should not change the zone of a player
without first obtaining the approval of all other players in that zone.

For example, if I, Amberyl, wished to work on a project together
with Annalyn and Tavella, I would @create an object (let's call it MyZone),
and then "@elock MyZone=*Amberyl|*Annalyn|*Tavella". This would allow
myself, Annalyn, and Tavella to control all objects in the zone.
(PLEASE NOTE: wizards should never be in a zone with anyone! It's far too
easy for a regular player to abuse an item belonging to that wizard).

Players may @chzone their own objects to a ZMO that they own,
or are in the enter lock of. It isn't necessary to be personally zoned
to a ZMO in order to be able to control objects in it (the only criterion
is the enter lock of the ZMO); it is perfectly possible to be zoned to
something else (or Nothing), and @chzone the stuff you build to the
desired zone.

Zones have several other nifty features. First of all, $-commands
on the ZMO are "global" to rooms that are part of that ZMO, and to things
which are personally part of that ZMO. Also, objects can perform a
"@zemit <zone> = <message>" to emit a message to all rooms in that
zone. This command is computationally expensive and costs 100 coins, but
it can be very useful if you have, for example, a space station which
uses an intercom system for announcements.


11.2     Parent room zones

Parent rooms are a slightly more complex version of zones.
The main difference is that, instead of the ZMO being a thing, the
ZMO is a room. All information above about object zones also applies
to parent rooms.

Parent rooms have several more useful properties. First,
a parent room is a bit like the Master Room. It is treated as "global"
by objects which are zoned to it. If you are in a room zoned to a
parent room, you can use exits in that parent room. You can also
use $-commands defined on objects placed in the parent room.

This essentially allows you to create small areas on the MUSH
with their own local "global" commands and exits, without cluttering
up the Master Room. Since local commands take precedence over global
ones, you don't have to worry about global commands interfering with
your local parent room ones.

Unless you want to use parent room exits, you should use
object zones. Object zones are faster, and cause less overhead for the
server to worry about; this is an important consideration if the
MUSH is big.

11.3      ZoneMaster players

One final type of zone control is possible, using a player with
the ZONE flag set. Such players, called ZoneMasters, behave like ordinary
players, but any object that they own is controlled by whomever passes
the ZoneMaster's enter lock. For convenience, objects which pass the
ZoneMaster's enter lock are referred to here as "zone controllers".

Zone controllers are able to @chown objects to the ZoneMaster.
However, such objects count against the original owner's quota, and the
object's creation cost remains charged to the original owner, not to the
ZoneMaster. This enables quotas to be set on individual players, while
still allowing a "builder character" to own all the objects.


The ZoneMaster is more secure than a ZMO, since INHERIT objects
may be placed within the zone without any abnormal danger; since all
objects within the zone have the same owner, there is no danger of having
one's unzoned objects @forced through a security hole. Unlike a standard
ZMO, however, the ZoneMaster does not act as a master object; $commands
are not inherited off it.

Note that this is different from standard zoning in that the
"zoned" objects are actually owned by the ZoneMaster; thus, it is possible
to use @chzone to place the object in yet another zone, for the purpose
of inherit $commands, and so forth.

11.4      Local wizard control

It is possible, through use of zones, to have "local wizards".
This is accomplished by @chzone'ing all players that you want the
local wiz to control, to a ZMO (or parent room; ZMO will be used in
this discussion to refer to both). This ZMO should be @elock'ed to
just that local wiz. That player will then have control over all objects
created by players in that zone. Unlike a real wizard, however, he may
not @force players.

This may or may not be desirable, depending on your philosophy
of administration (assuming you are a god). Local wizards have almost
all the powers of normal wizards, without the accountability and expected
responsibility of full wizards. Although certain systems, such as MUSE,
have used player ranks in a way similar to local wizards, they do not
give such complete control to non-wizard (or wizard-equivalent) players.

It is the recommendation of this writer that local wizard
control only be used if the MUSH is extremely large, and organized into
big, but mostly self-contained, groups which require an administrator who
must be able to control the objects of his underlings.


12.       The Fundamental Laws of Wizarding


The section below comes from a "lecture" that I've given new
wizards on MUSHes that I'm a "senior" wizard on. I've had several requests
for it in printed form, so it appears here, as kind of a summary to this
section of the manual. It summarizes rules for wizard conduct, and gives
a nutshell guide to wizard commands. The full lecture is available via
ftp from the same site where you obtained this manual; it will probably
be called "wiz-ethics" or something similar. All administrators are highly
encouraged to read the full lecture; this manual only hits the highlights.


12.1      Wizard Etiquette

There are three things that players REALLY hate, and which
generally constitute abuse of wizard powers. The first is @forcing a player
to do something. There's really never a reason to do this. You can almost
always duplicate the effect of a command that a player issues by just
doing it yourself. Forcing a player to say or pose something is obviously
unethical. Forcing a player's objects is also generally a bad idea.

Always ask permission before @teleporting a player, or teleporting to
a non-public location, even if the location is JUMP_OK. The first is
just courtesy; the only reason to ever teleport a player is if he
refuses to come of his own free will. It has the potential to mess up
some command the player is trying to execute; waiting a moment or two
for the player to come on his own isn't going to kill you. Following
the second rule will prevent you from teleporting into potentially
embarrassing situations. Just because someone is paging you doesn't
mean that he necessarily wants to talk to you in person.

Don't wander around DARK. If you're going to hang around dark because
you don't want people bothering you, stay in one of your rooms.  If
you encounter another player, announce your presence. The same thing
applies to puppets who are DARK. Some people believe that the best way
to handle player discipline is to teleport to their location, DARK,
and spy on them. This is a breach of ethics, in most cases. Unless you
believe that players are deliberately conspiring to destroy the MUSH,
do not use DARK for anything other than hanging around without getting
bothered by player pages.

Two other brief points: don't examine private objects unless you need
to, and ESPECIALLY, do not use wizard powers to take code or code
segments without permission. In addition, never, ever, wiz while
intoxicated!  Your judgement isn't steady, and you are also very
likely to accidentally mistype a command and cause some sort of minor
(or major) disaster.


12.2       The Five-Step Method of Player Management

If a player is behaving inappropriately, start with warnings and move
up to more direct action. The exception are spammers and those who are
being destructive towards the database; @boot and/or @destroy those
players immediately.

For players who are simply being obnoxious, breaking some of the MUSH
rules, etc., page them and politely tell them that their behavior is
unacceptable. If they don't respond to this "nice" warning within five
or ten minutes, page them again with a more strongly worded warning.
If they continue to misbehave, try a threat: "Do that one more time
and you're going to be @booted."  The next thing to try, if the twink
is being stubborn, is setting the twink GAG. Most people will
disconnect of their own accord if they're gagged. For really
obnoxious, stubborn people, you can then resort to @boot. If the twink
returns, do a @newpassword. Note that if you are planning on doing a
@newpassword to lock out a twink, you should @newpassword _before_ you
@boot, since otherwise, the player can log right back in before you
have a chance to type the @newpassword command.

The reason for using @newpassword instead of @toad or @destroy is that
@newpassword is reversible. You should never use @toad or @destroy on
a player who owns stuff; that is a decision for God to make. Just do a
@newpassword and send mail to the other wizards.

   Summary:
      1. Nice warning
      2. Not nice warning / threat
      3. Gag
      4. Boot
      5. Newpassword


12.3       When to use wiz commands

@allhalt:  This is an emergency-only command. It will halt all commands on
           all objects, and clears out the wait queue. If there are any
           objects which need to run continuously, this command should be
           used as a last resort. Try to be considerate and retrigger objects
           that need to run continuously, if you do an allhalt.
@boot:     Never @boot without a good reason. If a player is on twice and
           he can't kill one of his connections, he will generally page you
           and ask for a @boot; don't do one unless he gives you permission.
           The other use for @boot is detailed in the previous section.
@chownall: Never, ever, do one of these without the explicit permissions of
           both of the parties involved. It's not a bad idea to send mail
           to God (or at least make sure he knows) if you do one of these.
@dbck:     The @dbck command is used to force a database consistency check.
           All GOING objects get recycled. Unless you know what you're
           doing, there's no real point to doing one.
@purge:    This checks the destroyed object list for corruption. It's
           normally done as part of a @dbck.
@dump:     In 1.x, you don't want to do overlapping dumps. If you don't
           have FORK enabled, you want to shout before doing one, because
           it will probably cause quite a bit of lag. Otherwise, @wizwall
           that you're doing a dump, so the other wizards know not to do
           one right after you do.
@login:    You can turn MUSH logins on and off with this command. Unless
           you've got some kind of emergency which necessitates locking out
           all players, don't use this. More importantly, don't forget to
           turn logins back on after the emergency is over.
@daytime:  This turns on or off computationally expensive commands. God
           generally makes the decision when these commands should be
           enabled. Turning them off when they should be turned on probably
           won't hurt anything, but turning them on when they need to be
           off has the potential to get God very upset with you.
           Only 1.50 has this command.
@shutdown: In general, only wizards with access to the MUSH account should
           do @shutdowns, so they can bring the MUSH back up afterwards.
           The exception is if the MUSH is not autorestarted, and needs to
           be taken down for a machine reboot or something similar.
           If the database has somehow been corrupted, a @shutdown may or
           may not be a good idea -- this command automatically does a
           @dump, and you might be making your problem semi-permanent.
           When in doubt, contact God; to shut down the game without doing
           a @dump, use @shutdown/abort.


The most important thing to remember: USE COMMON SENSE.

------

That's it for wizard commands and advice.
Comments, corrections, and suggestions should be emailed to Amberyl,
at lwl@netcom.com

Amberyl's Wizard Lecture

This is an expansion of the section of the MUSH manual called
"The Fundamental Laws of Wizarding".   Questions and comments
should go to lwl@digex.net. The content of the lecture has been
unmodified since 10/23/94.


Administrators on a MUSH have a considerable amount of power. With that
power comes the responsibility to use it wisely, for the actions of
an administrator reflect not only on himself, but on the MUSH as a whole.
Because an admin is in a position of power, he should attempt to set a
positive example in all dealings, whether in-character or out-of-character,
Common sense will usually suggest a decent solution to a given problem;
there are, however, some situations where the ethical and "correct" thing
to do is not immediately obvious.


Players are frequently paranoid about privacy. This is one "right" that
you should _always_ attempt to respect; thus, this lecture begins with
a discussion of the DARK flag. When you are DARK in a room, players who
do a 'look' cannot see you, and you do not appear on the WHO list, but
a @sweep of the room _does_ show that you are listening and connected.
Therefore, there is a chance that you will be noticed, and, if you are
"illegally" in the room DARK, it is almost certain that the players in
the room will be quite upset.

The reason why players don't like DARK wizards wandering around should
be obvious -- they're afraid of private conversations being snooped on.
Therefore, whenever you go _anyplace_ DARK, the first thing you should
type upon entering the room is a "hello" or similar announcement of your
presence. Make this a habit! If you do it regularly, even when the players
in the room know you'll be entering DARK, there's less of a chance you
will forget at some crucial moment. If you plan to be DARK, and wandering
around, for an extended period of time, in order to arbitrate an RPG
conflict or similar event, the players involved should, if possible,
know of your presence, and if a private conversation begins, it is your
ethical responsibility to inform the players of your presence immediately,
_even if_ this lets players know that they are being judged. Your personal
responsibility to promote privacy overrides any RPG mechanics.

Some MUSH gods may allow their wizards to go DARK in order to observe
players whom are suspected of trying to harm the game, either by harming
the database or crashing the server; some other gods may also allow
wizards to go DARK to observe the actions of a player harassing other
players. In the latter case, the wizard should indicate his presence to
the players in the room who are not "under suspicion".

I cannot emphasize enough how important it is to obey the protocols
for using the DARK flag. This is one of the greatest sources of
player distrust in wizards, because it is so _easy_ to abuse. Players
should be able to have private conversations without doing a @sweep
all the time. While privacy on a MUD is never, ever, guaranteed, you
should do your best to contribute towards it.


The second of the frequently-abused wizard powers is @teleport. There
are a number of rules that should be observed when @teleporting. First
of all, never teleport a player without warning him first. If possible,
the player should page you with an acknowledgement before you do the
actual @tel. This prevents, for example, an untimely @teleport wrecking
someone's set of a @desc on a room. No one enjoys suddenly being yanked
to another room, and it doesn't hurt you to page the player first.

Never teleport to a room with players without asking the permission of
the players there first. The exception to this are public hangouts.
A room which is merely JUMP_OK is not necessarily a public hangout; use
some judgement when determining whether or not rooms are public. Unless
the room is clearly public, ask first; it doesn't hurt you to be polite.

If permission is not likely to be granted, then notify all players in
the room (@remit works well for this) that you are going to be coming
in, before entering the room. You should wait a moment between the of
the announcement and the teleport; this should prevent you from hearing
something that you shouldn't.

Never make assumptions about whether or not it's okay to teleport into
a situation. For example, just because a player is paging you for help
with coding some complex object _doesn't_ mean that he wants you to
teleport into his room and help him out. I know this from experience --
as a new wizard, I once struggled to help someone, remotely, with a
complex MUSHcoded object, and, finally, after fifteen minutes of
fruitless pages, I finally decided to teleport in and see what errors
the object was outputting. Unfortunately, I bamf'ed myself straight
into the middle of a hot 'n steamy tinysex session. Since then, I've
made it a rule to _always_ ask before teleporting.


Don't abuse "examine" or the power to see private information like sites.
The rules for examining private objects will vary from God to God. On a
MUSH where a strict theme is enforced, wizards will probably be permitted
to examine anything in order to check for theme consistency. You should
never share or show any object, or part of an object, that is not yours
to another player, without getting the permission of the owner. Also,
don't steal code. "Stealing code" includes @decompiling/logging/cloning
without permission, even if you're just using the code for your own
personal edification or enjoyment. If it's that important to you, ask
permission.

Sitenames should never be given out. If a player is Unfindable, you
shouldn't give out his location. Some people MUD to escape people they
know in Real Life; some players carry vendettas cross-MUD. Other people
simply prefer not to let others know where they are, VR or RL. You
should respect this desire.


You should generally avoid modifying other people's objects, even if
you're fixing code problems or typos. The only exception to this is
publicly owned building owned by a wizard-played builder character
(the core landscape for the MUSH, the downtown area, etc.)  If you
encounter an object which is inefficiently programmed or looping,
and thus slowing down the game for everyone else, simply set it HALT
and mail the owner; don't fix the problem.

Also, don't @destroy anything of anyone else's unless they explicitly
ask you to. If it's an item which is illegal in some way, send the
owner a warning, and give him a certain period of time (a few days,
usually, depending on how often the player logs in) in which to get
rid of it. If it's not gone by the end of the period, then you can
destruct it. If the illegal item is sitting in a public place, you
should feel free to teleport it back to its owner.


Never, ever, @force a player, unless it is _absolutely_ necessary.
For the same reasons, don't use @trigger and similar commands to make
a player do something against his will. Also, don't change the attributes
on a player; for example, it is generally considered unethical to change
a player's description to something humiliating. Wizards might occassional
get into practical joke wars, but mortals shouldn't become involved.
If you need to change an attribute on a player, make sure you copy the
old attribute to a backup attribute on the player, so that they can
recover it later, if need be.


Wizards can pile huge numbers of things on the queue, and make use of
computationally expensive commands like @find and @search with impunity.
If you need to do something that will severely lag the game, do it when
there aren't many players on. Also, note that very large @dolists cause
the MUSH process size to grow, and should be avoided whenever possible.


Wizards should be uselocked at all times. Private wiztoys should also
be uselocked. Any item with wizard powers MUST be checked for security;
if you are not a competent enough MUSH programmer to be able to do this
yourself, you should show the item to a wizard who is. In addition,
administrators and objects owned by administrators should never be zoned
to a Zone to which mortals have access.

Never give a wiz-power item to a mortal. If a mortal absolutely MUST have
a wizard-power item to do what he wants, consider @chown'ing that particular
system to a wizard. If this isn't possible, then make absolutely certain
that the mortal is trustworthy. Every administrator on the game should be
aware of all wiz-power items in the hands of mortals.


Avoid annoying players with shouts. @wall cannot be blocked, and, therefore,
you should make sure that everything you shout is informative and necessary.
On a very small, friendly MUSH, it might be considered acceptable to @wall
hello and goodbye; on most MUSHes, though, especially RPG ones where "mood"
and "atmosphere" are important, @walls of that sort should be avoided.
Shouting to announce a @shutdown in five minutes is acceptable; shouting
to announce game problems is acceptable. Shouting to announce that you've
had a bad day and shouldn't be paged should probably be avoided. First of
all, it makes you sound like a twit; second, it accomplishes nothing useful
and implies, "stay out of my way or something bad will happen to you."
If you really want to avoid player pages, go DARK and set a pagelock.
Players shouldn't be afraid of you on a "professional" wizard level, and
you should try to avoid actions which cause players to fear you.


Wizards should be thoroughly familiar with MUSH. While "psychocoder" status
is not necessary, a good understanding of MUSH mechanics is necessary. Never
type a command as a wizard without understanding what it does. You should
have read the MUSH manual; even if you don't understand all of it, you should
read and understand the wizard section.

Every object in the Master Room should have a specific purpose. ONLY
objects used for global commands should be in the Master Room. As few
total attributes should be on Master Room objects as possible; any
data objects should be contained on separate objects NOT in the master
room, and the Master Room objects should NOT be parented to the data
objects. Every attribute in the Master Room represents another attribute
that must be checked for $commands when a player types something; thus,
having unnecessary objects and attributes in the room will slow the
game down. If you need a place to store objects used as global parents
and whatnot, use a room _other_ than the Master Room. Master Room code
should, obviously, be as efficient as possible.


There should be at least one wizard on the game who is familiar with the
technical aspects of the server. Also, backups should be done on a weekly
basis, or more often, if possible. This will save you a lot of grief should
your database get eaten by a bug or other problem. If your currently-running
game begins to show signs of database corruption, it is probably a good idea
NOT to @shutdown; instead, log into the game account and 'kill -9' the MUSH
process. It's also a good idea for wizards to know the phone number of the
God / codehack / site admin, for emergencies.

If you have the necessary technical background, you are highly encourage
to at least take a glance at the server code. Knowledge of the server
workings helps your MUSH programming ability, and enables you to make
intelligent decisions that involve disk, memory, and CPU usage. Also,
get to know wizards on other MUSHes; this gives you people to go to for
help should something unfortunate befall your MUSH.


Never MUSH while intoxicated or otherwise not fully in control of your
actions. If you observe another wizard who is MUSHing drunk, @boot them.
The other wizard will probably be annoyed, but this is better than having
damage inadvertently caused by someone who isn't thinking clearly.

Know when to log off or back out of a situation. If you feel like you're
about to explode, get up, walk around for a bit, get a drink of water,
and come back when you feel like you're ready to cope rationally with
the situation. If possible, call in another administrator to handle the
situation. Never, ever, perform wizard actions out of anger; it is likely
that you will regret them later.


A wizard's ability to deal with players is usually the final test of his
skills. Troublemaking players are quick to find wizards who are easily
provoked, and frequently enjoy pushing all the buttons they can. When you
page a player, no matter how annoyed you might be, you should try to
remain calm and polite. Don't swear at players, or behave in a manner
that would allow the player to focus a discussion away from his wrongdoing
to a mistake _you_ made.

Players who are spamming or exhibiting behavior detrimental to the server
or database should be @booted; if it's a one-time-deal character like
"You_Suck", a @destroy is also in order. Other players should receive
warnings before any direct action is taken.

If a player is being obnoxious or breaking MUSH rules, page them and politely
let them know that their behavior is unacceptable. If the player is not idle,
and does not respond to your page within a few minutes, repeat your page. If
the player simply ignores you, or refuses to change his behavior, page with
a stronger warning, but continue to remain polite. If this doesn't work,
tell them, "If you don't stop that, I'm going to @boot you."

This will normally at least open a dialogue between yourself and the player
in question. If the player isn't willing to discuss it, and continues the
obnoxious behavior, set them GAG. Most players will quit voluntarily. For
really stubborn players, @boot will work. If they come back and continue to
be annoying, then @newpassword them. You should NOT @destroy a player who
isn't a one-shot annoyance. @destroy is not reversible, but a player can
be re-@newpassworded should he decide to come back and play by the rules.

When talking to a player, you should attempt to remain calm and polite,
no matter how much the player is trying to provoke you. Ignore personal
insults, obscenities, and the like, if some useful discussion is occurring.
If the player is just continuing to be annoying, end the discussion and
simply tell them, "Do this again and I'll @boot you."  You're not required
to be a saint or martyr.

Whenever you enter a major conflict with a player, you should log the
situation, if possible. You should send the other wizards, via email,
a summary of the situation, and, if necessary, the log. This will prevent
the player from accusing you of saying or doing things that you did not,
and will give you a "record" of the player's behavior, in case the player
claims that he didn't do what you claimed he did. The SUSPECT flag and
@comment attribute are also good for letting other wizards know about
suspicious players.


These guidelines aren't here to make the task of wizarding more difficult
for you. They exist to provide some basic guidelines of ethical behavior;
in general, if you follow these guidelines, players will find it quite
difficult to accuse you of abusing your wizpowers. They thus work for
_your_ protection, as well as the players'.  Players frequently take
wizard mistakes personally and seriously, and may decide, "because
wizard X did this, all other wizards probably do, too."  Players who are
paranoid tend to be more difficult to deal with; thus, for the sake of
your sanity and that of every other wizard who ever has to deal with
that player, try to avoid giving the a reason to be paranoid.  If you
consistently have personal problems with a player, you should also avoid
wizard dealings with that player; have another wizard handle the situation
instead.

In all things, use common sense, and try to remain calm and impartial.
When all else fails, log off.


[ Based on a lecture first given on TinyKrynn, 2/92, by Amberyl. ]

------------
Server output starts as follows;-

